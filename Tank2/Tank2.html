<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tank2</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
  <canvas id="_Canvas" width="560" height="560"></canvas>
</body>
</html>

<script>

class DrawableObject {
    isAlive = true ;
    isProcessed = false ;
    isMoved = false ;
    x = 0 ;
    y = 0 ;
    rotation = 0 ;
    _top=0;
    _bottom=0;
    _left=0;
    _right=0;
    beforeProcess() {
        this.isProcessed = false ;
        this.isMoved = false ;
    }
    _process() {
        if ( this.isProcessed ) {
            return ;
        }
        this.process();
        this.isProcessed = true ;
    }
    process() {}
    moveTo( newX, newY, newRotation ) {
        this.isMoved = true ;
        let oldX = this.x ;
        let oldY = this.y ;
        let oldRotation = this.rotation ;
        this.x = newX ;
        this.y = newY ;
        this.rotation = newRotation ;
        let objs = world.overlapObjects(this) ;
        for( let i=0; i<objs.length; i++ ) {
            objs[i].touched(this) ;
            if ( !this.moveCheck(objs[i]) ) {
                this.x = oldX ;
                this.y = oldY ;
                this.rotation = oldRotation ;
                this.isMoved = false ;
            }
        }
    }
    calculateEndPoint(x1, y1, length, angleInDegrees) {
        // 將角度從度轉換為弧度
        const angleInRadians = angleInDegrees * (Math.PI / 180);
        
        // 計算另一端點的座標
        const x2 = x1 + length * Math.sin(angleInRadians);
        const y2 = y1 + length * Math.cos(angleInRadians);
        
        return { x: x2, y: y2 };
    }
    top() {
        switch( this.rotation ) {
            case 0:
                return this.y-this._top;
            case 90:
                return this.y-this._left;
            case 180:
                return this.y-this._bottom;
            case 270:
                return this.y-this._right;
        }
    }
    left() {
        switch( this.rotation ) {
            case 0:
                return this.x-this._left;
            case 90:
                return this.x-this._bottom;
            case 180:
                return this.x-this._right;
            case 270:
                return this.x-this._top;
        }
    }
    bottom() {
        switch( this.rotation ) {
            case 0:
                return this._bottom+this.y;
            case 90:
                return this._right+this.y;
            case 180:
                return this._top+this.y;
            case 270:
                return this._left+this.y;
        }
    }
    right() {
        switch( this.rotation ) {
            case 0:
                return this._right+this.x;
            case 90:
                return this._top+this.x;
            case 180:
                return this._left+this.x;
            case 270:
                return this._bottom+this.x;
        }
    }

    afterProcess() { }
    paint() {}
    moveCheck(obj) {

        return true ;
    }
    touched(obj) {
    }
}

class Stone extends DrawableObject {
    _top = 15;
    _bottom = 15;
    _left = 15 ;
    _right = 15 ;
    hp = 5 ;
    constructor(x, y) {
        super() ;
        this.x = x ;
        this.y = y ;
    }
    paint() {
        ctx.fillStyle = `rgb(0,0,0)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    touched(obj) {
        if ( obj instanceof Bullet ) {
            if ( this.hp-- <= 0 ) {
                this.isAlive = false ;
            }
        }
    }
}

class Tank extends DrawableObject {
    distByStep=15 ;
    delayCount=15;
    _top=20;
    _bottom=20;
    _left=15;
    _right=15;
    rotation=0;
    dist=0;
    dirAry=[0,90,180,270] ;
    bulletDelay=0;
    constructor(x, y )  {
        super() ;
        this.x = x ;
        this.y = y ;
    }
    paint() {
        ctx.fillStyle = `rgb(55,55,255)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    fire() {
        switch( this.rotation ) {
            case 0:
                world.add( new Bullet(this.x,this.top()-10, this.rotation, true) );
                break;
            case 90:
                world.add( new Bullet(this.right()+10,this.y, this.rotation, true) );
                break;
            case 180:
                world.add( new Bullet(this.x,this.bottom()+10, this.rotation, true) );
                break;
            case 270:
                world.add( new Bullet(this.left()-10,this.y, this.rotation, true) );
                break;
        }
    }
    process() {
        if ( this.delayCount-- <= 0 ) {
            this.delayCount = 3 ;
        } else {
            return ;
        }
        if ( this.bulletDelay-- < 0 ) {
            this.bulletDelay = 5 ;
            this.fire() ;
        }
        let newRotation = this.rotation ;
        if ( this.dist-- <=0 ) {
            newRotation = this.dirAry[ Math.floor( Math.random()*4 ) ];
            this.dist = Math.floor( Math.random()*10 )+10 ;
        }
        switch( newRotation ) {
            case 0:
                if ( this.top()-10 <=0  ) {
                    this.dist = 0 ;
                } else {
                    this.moveTo( this.x, this.y-10, newRotation )  ;
                }
                break;
            case 90:
                if ( this.right()+10 >= WORLD_HEIGHT ) {
                    this.dist = 0;
                } else {
                    this.moveTo( this.x+10, this.y, newRotation )  ;
                }
                break;
            case 180:
                if ( this.bottom()+10 >= WORLD_WIDTH ) {
                    this.dist = 0 ;
                } else {
                    this.moveTo( this.x, this.y+10, newRotation )  ;
                }
                break;
            case 270:
                if ( this.left()-10 <= 0 ) {
                    this.dist = 0 ;
                } else {
                    this.moveTo( this.x-10, this.y, newRotation )  ;
                }
                break;
        }
    }
    moveCheck(obj) {
        if ( obj instanceof Stone || obj instanceof Tank ) {
            return false ;
        }
        return true ;
    }
    touched(obj) {
        if ( obj instanceof Bullet ) {
            if ( !obj.isEnemy) {
                this.isAlive = false ;
                return false ;
            }
        }
    }
}

class MyTank extends DrawableObject {
    distByStep=15 ;
    gamepadIdx= 0;
    delayCount=0;
    _top=30;
    _bottom=30;
    _left=15;
    _right=15;
    rotation=0;
    constructor(x, y, gamepadIdx) {
        super() ;
        this.gamepadIdx = gamepadIdx ;
        this.x = x ;
        this.y = y ;
    }
    paint() {
        ctx.fillStyle = `rgb(0,255,255)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    process() {
        if ( this.delayCount++ > 1 ) {
            this.delayCount=0;
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[this.gamepadIdx] ;
            if (gamepad) {
                if ( gamepad.axes[0] == 1 ) {
                    //console.log("right") ;
                    this.keyRight();
                }
                if ( gamepad.axes[0] == -1 ) {
                    //console.log("left") ;
                    this.keyLeft();
                }
                if ( gamepad.axes[1] == 1 ) {
                    //console.log("down") ;
                    this.keyDown();
                }
                if ( gamepad.axes[1] == -1 ) {
                    //console.log("up") ;
                    this.keyUp() ;
                }
                if ( gamepad.buttons[0].pressed ) {
                    //console.log("space") ;
                    this.keySpace();  
                }
                if ( gamepad.buttons[1].pressed ) {
                    this.makeStone();  
                }
//                console.log(`x=${this.x}, y=${this.y}`);
            }
        }
    }
    keyUp() {
        if ( this.rotation == 0 ) {
            if ( this.top()-this.distByStep >= 0 ) {
               this.moveTo( this.x, this.y-this.distByStep, this.rotation  ) ;
            }
        } else {
            this.moveTo( this.x, this.y, 0 ) ;
        }
    }
    keyDown() {
        if ( this.rotation == 180 ) {
            if ( this.bottom()+this.distByStep < WORLD_HEIGHT ) {
                this.moveTo(  this.x, this.y+this.distByStep, this.rotation  ) ;
            }
        } else {
            this.moveTo( this.x, this.y, 180 ) ;
        }
    }
    keyRight() {
        if ( this.rotation == 90 ) {
            if ( this.right()+this.distByStep  < WORLD_WIDTH ) {
                this.moveTo( this.x+this.distByStep , this.y, this.rotation ) ;
            }
        } else {
            this.moveTo( this.x, this.y, 90 ) ;
        }
    }
    keyLeft() {
        if ( this.rotation == 270 ) {
            if ( this.left()-this.distByStep  >= 0 ) {
                this.moveTo( this.x-this.distByStep , this.y, this.rotation ) ;
            }
        } else {
            this.moveTo( this.x, this.y, 270 ) ;
        }
    }
    keySpace() {
        switch( this.rotation ) {
            case 0:
                world.add( new Bullet(this.x,this.top()-10, this.rotation, false) );
                break;
            case 90:
                world.add( new Bullet(this.right()+10,this.y, this.rotation, false) );
                break;
            case 180:
                world.add( new Bullet(this.x,this.bottom()+10, this.rotation, false) );
                break;
            case 270:
                world.add( new Bullet(this.left()-10,this.y, this.rotation, false) );
                break;
        }
    }
    makeStone() {
        switch( this.rotation ) {
            case 0:
                world.add( new Stone(this.x,this.bottom()+this.distByStep, this.rotation) );
                break;
            case 90:
                world.add( new Stone(this.left()-this.distByStep,this.y, this.rotation) );
                break;
            case 180:
                world.add( new Stone(this.x,this.top()-this.distByStep, this.rotation) );
                break;
            case 270:
                world.add( new Stone(this.right()+this.distByStep,this.y, this.rotation) );
                break;
        }
    }
    moveCheck(obj) {
        if ( obj instanceof Stone ) {
            return false ;
        }
        return true ;
    }
    touched(obj) {
        if ( obj instanceof Bullet ) {
            if ( obj.isEnemy ) {
                this.isAlive = false ;
                return false ;
            }
        }
    }
} 



class Bullet extends DrawableObject {
    dist = 20 ;
    _top=5;
    _bottom=5;
    _left=3;
    _right=3;
    isEnemy=false ;
    constructor(x,y,rotation, isEnemy) {
        super();
        this.x = x ;
        this.y = y ;
        this.rotation = rotation ;
        this.isEnemy = isEnemy ;
    }
    
    process() {
        if ( this.dist-- <=0 ) {
            this.isAlive = false ;
            return ;
        }
        switch( this.rotation ) {
            case 0:
                if ( this.top()-10 <=0  ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x, this.y-10, this.rotation )  ;
                }
                break;
            case 90:
                if ( this.right()+10 > WORLD_HEIGHT ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x+10, this.y, this.rotation )  ;
                }
                break;
            case 180:
                if ( this.bottom()+10 > WORLD_WIDTH ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x, this.y+10, this.rotation )  ;
                }
                break;
            case 270:
                if ( this.left()-10 <= 0 ) {
                    this.isAlive= false ;
                } else {
                    this.moveTo( this.x-10, this.y, this.rotation )  ;
                }
                break;
        }
    }
    paint(){
        ctx.fillStyle = `rgb(0,0,255)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    moveCheck(obj) {
        if ( obj instanceof Stone ) {
            this.isAlive = false ;
            return false ;
        }
        return true ;
    }
}

class World {
    objects = [] ;
    tankLastCreateTime = 0 ;
    constructor() {
    }
    createTank() {
        if ( this.tankLastCreateTime == 0 ) {
            world.add( new Tank(300, 300) ) ;
            this.tankLastCreateTime = Date.now() ;
        }
        if ( Date.now() - this.tankLastCreateTime > 3000 ) {
            world.add( new Tank(300, 300) ) ;
            this.tankLastCreateTime = Date.now() ;
        }
    }
    process() {
        this.createTank() ;
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.beforeProcess() ;
            }
        }      
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj._process() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.afterProcess() ;
            }
        }      
        this.paint();
    }

    paint() {
        this.drawBackground();
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if (obj.isAlive ){
                obj.paint() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
    }

    drawBackground(){
        ctx.fillStyle = `rgb(255,255,255)` ;
        ctx.fillRect( 0, 0, CELL_SIZE*TOTAL_COLS, CELL_SIZE*TOTAL_ROWS ) ;

        ctx.beginPath();
        ctx.strokeStyle = "orange";
        for (let i=0;i<TOTAL_COLS+1;i++){
            ctx.moveTo(CELL_SIZE*i,0 );
            ctx.lineTo(CELL_SIZE*i,CELL_SIZE*TOTAL_ROWS);
        } 
        for (let j=0;j<TOTAL_ROWS+1;j++){
            ctx.moveTo(0,CELL_SIZE*j );
            ctx.lineTo(CELL_SIZE*TOTAL_COLS, CELL_SIZE*j );    
        }
        ctx.stroke();
    }

    add( obj ) {
        let objs = this.overlapObjects(obj) ;
        for( let i=0; i<objs.length; i++ ) {
            objs[i].touched(obj) ;
            if ( !obj.moveCheck(objs[i]) ) {
                return false;
            }
        }
        if ( obj.isAlive ) {
            this.objects.push( obj ) ;
            return true ;
        }
        return false ;
    }

    overlapObjects(obj) {
        let objs = [] ;
        for( let i=0; i<this.objects.length; i++ ) {
            let obj2 = this.objects[i] ;
            if ( obj === obj2 ) {
                continue ;
            }
            if ( obj.right() <= obj2.left() ) {
                continue ;
            }
            if ( obj.top() >= obj2.bottom() ) {
                continue ;
            }
            if ( obj.left() >= obj2.right() ) {
                continue ;
            }
            if ( obj.bottom() <= obj2.top() ) {
                continue ;
            }
            //console.log(`${obj.x}, ${obj.y}, ${obj.rotation} overlap with ${obj2.x}, ${obj2.y}, ${obj2.rotation} `);
            objs.push( obj2 ) ;
        }
        return objs ;
    }
}
//============================================================================
//============================================================================
//============================================================================

function run(time) {
    if (!isRunning){
        return ;
    }

    if (lastTime === 0) {
        lastTime = time;
    }

    // 計算自上次更新以來經過的時間
    const deltaTime = time - lastTime
    if ( deltaTime > 30 ) {
        world.process();
        lastTime = time ;
    }
    requestAnimationFrame(run);

}

//----------------------------------------------------------------------
const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');    

const TOTAL_ROWS = 35 ;
const TOTAL_COLS = 35 ;
const CELL_SIZE = 15 ;
const WORLD_WIDTH = TOTAL_COLS*CELL_SIZE ;
const WORLD_HEIGHT = TOTAL_ROWS*CELL_SIZE;
let lastTime = 0 ;

let world = new World() ; 
//world.add( new MyTank(30,400,0) ) ;
//world.add( new MyTank(300, 400, 2) ) ;

//world.add( new Stone(15*10, 15*20) ) ;
//world.add( new Stone(15*12, 15*25) ) ;
//world.add( new Stone(15*18, 15*10) ) ;
//world.add( new Stone(15*8, 15*30) ) ;

requestAnimationFrame(run);
</script>