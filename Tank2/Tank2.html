<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tank2</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
  <canvas id="_Canvas" width="560" height="560"></canvas>
</body>
</html>

<script>

class DrawableObject {
    isAlive = true ;
    isProcessed = false ;
    isMoved = false ;
    x = 0 ;
    y = 0 ;
    dir = 0 ;
    _top=0;
    _bottom=0;
    _left=0;
    _right=0;
    beforeProcess() {
        this.isProcessed = false ;
        this.isMoved = false ;
    }
    _process() {
        if ( this.isProcessed ) {
            return ;
        }
        this.process();
        this.isProcessed = true ;
    }
    process() {}
    moveTo( newX, newY ) {
        this.isMoved = true ;
        let oldX = this.x ;
        let oldY = this.y ;
        this.x = newX ;
        this.y = newY ;
        let objs = world.overlapObjects(this) ;
        for( let i=0; i<objs.length; i++ ) {
            objs[i].touched(this) ;
            if ( !this.moveCheck(objs[i]) ) {
                this.x = oldX ;
                this.y = oldY ;
                this.isMoved = false ;
            }
        }
    }
    top() {
        switch( this.dir ) {
            case 0:
                return this.y-this._top;
            case 90:
                return this.y-this._left;
            case 180:
                return this.y-this._bottom;
            case 270:
                return this.y-this._right;
        }
    }
    left() {
        switch( this.dir ) {
            case 0:
                return this.x-this._left;
            case 90:
                return this.x-this._bottom;
            case 180:
                return this.x-this._right;
            case 270:
                return this.x-this._top;
        }
    }
    bottom() {
        switch( this.dir ) {
            case 0:
                return this._bottom+this.y;
            case 90:
                return this._right+this.y;
            case 180:
                return this._top+this.y;
            case 270:
                return this._left+this.y;
        }
    }
    right() {
        switch( this.dir ) {
            case 0:
                return this._right+this.x;
            case 90:
                return this._top+this.x;
            case 180:
                return this._left+this.x;
            case 270:
                return this._bottom+this.x;
        }
    }

    afterProcess() { }
    paint() {}
    moveCheck(obj) {

        return true ;
    }
    touched(obj) {
    }
}

class Stone extends DrawableObject {
    _top = 15;
    _bottom = 15;
    _left = 15 ;
    _right = 15 ;
    hp = 5 ;
    constructor(x, y) {
        super() ;
        this.x = x ;
        this.y = y ;
    }
    paint() {
        ctx.fillStyle = `rgb(0,0,0)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    touched(obj) {
        if ( obj instanceof Bullet ) {
            if ( this.hp-- <= 0 ) {
                this.isAlive = false ;
            }
        }
    }
}

class MyTank extends DrawableObject {
    distByStep=15 ;
    gamepadIdx= 0;
    delayCount=0;
    _top=30;
    _bottom=30;
    _left=15;
    _right=15;
    dir=0;
    constructor(x, y, gamepadIdx) {
        super() ;
        this.gamepadIdx = gamepadIdx ;
        this.x = x ;
        this.y = y ;
    }
    paint() {
        ctx.fillStyle = `rgb(0,255,255)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    process() {
        if ( this.delayCount++ > 1 ) {
            this.delayCount=0;
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[this.gamepadIdx] ;
            if (gamepad) {
                if ( gamepad.axes[0] == 1 ) {
                    //console.log("right") ;
                    this.keyRight();
                }
                if ( gamepad.axes[0] == -1 ) {
                    //console.log("left") ;
                    this.keyLeft();
                }
                if ( gamepad.axes[1] == 1 ) {
                    //console.log("down") ;
                    this.keyDown();
                }
                if ( gamepad.axes[1] == -1 ) {
                    //console.log("up") ;
                    this.keyUp() ;
                }
                if ( gamepad.buttons[0].pressed ) {
                    //console.log("space") ;
                    this.keySpace();  
                }
                if ( gamepad.buttons[1].pressed ) {
                    this.makeStone();  
                }
//                console.log(`x=${this.x}, y=${this.y}`);
            }
        }
    }
    keyUp() {
        if ( this.dir == 0 ) {
            if ( this.top()-this.distByStep >= 0 ) {
                this.moveTo( this.x, this.y-this.distByStep  ) ;
            }
        }
        this.dir = 0 ;
    }
    keyDown() {
        if ( this.dir == 180 ) {
            if ( this.bottom()+this.distByStep <= WORLD_HEIGHT ) {
                this.moveTo(  this.x, this.y+this.distByStep  ) ;
            }
        }
        this.dir = 180 ;
    }
    keyRight() {
        if ( this.dir == 90 ) {
            if ( this.right()+this.distByStep  <= WORLD_WIDTH ) {
                this.moveTo( this.x+this.distByStep , this.y ) ;
            }
        }
        this.dir = 90 ;
    }
    keyLeft() {
        if ( this.dir == 270 ) {
            if ( this.left()-this.distByStep  >= 0 ) {
                this.moveTo( this.x-this.distByStep , this.y ) ;
            }
        }
        this.dir = 270;
    }
    keySpace() {
        switch( this.dir ) {
            case 0:
                world.add( new Bullet(this.x,this.top()-10, this.dir) );
                break;
            case 90:
                world.add( new Bullet(this.right()+10,this.y, this.dir) );
                break;
            case 180:
                world.add( new Bullet(this.x,this.bottom()+10, this.dir) );
                break;
            case 270:
                world.add( new Bullet(this.left()-10,this.y, this.dir) );
                break;
        }
    }
    makeStone() {
        switch( this.dir ) {
            case 0:
                world.add( new Stone(this.x,this.bottom()+this.distByStep, this.dir) );
                break;
            case 90:
                world.add( new Stone(this.left()-this.distByStep,this.y, this.dir) );
                break;
            case 180:
                world.add( new Stone(this.x,this.top()-this.distByStep, this.dir) );
                break;
            case 270:
                world.add( new Stone(this.right()+this.distByStep,this.y, this.dir) );
                break;
        }
    }
    moveCheck(obj) {
        //console.log(`moveCheck:`) ;
        console.log(obj) ;
        if ( obj instanceof Stone ) {
            return false ;
        }
        return true ;
    }
    touched(obj) {
        if ( obj instanceof Bullet ) {
            this.isAlive = false ;
            return false ;
        }
    }
}

class Bullet extends DrawableObject {
    dist = 20 ;
    _top=5;
    _bottom=5;
    _left=3;
    _right=3;
    constructor(x,y,dir) {
        super();
        this.x = x ;
        this.y = y ;
        this.dir = dir ;
    }
    
    process() {
        if ( this.dist-- <=0 ) {
            this.isAlive = false ;
            return ;
        }
        switch( this.dir ) {
            case 0:
                if ( this.top()-10 <=0  ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x, this.y-10 )  ;
                }
                break;
            case 90:
                if ( this.right()+10 > WORLD_HEIGHT ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x+10, this.y )  ;
                }
                break;
            case 180:
                if ( this.bottom()+10 > WORLD_WIDTH ) {
                    this.isAlive = false ;
                } else {
                    this.moveTo( this.x, this.y+10 )  ;
                }
                break;
            case 270:
                if ( this.left()-10 <= 0 ) {
                    this.isAlive= false ;
                } else {
                    this.moveTo( this.x-10, this.y )  ;
                }
                break;
        }
    }
    paint(){
        ctx.fillStyle = `rgb(0,0,255)` ;
        ctx.fillRect( this.left(),  this.top(),  this.right()-this.left(),  this.bottom()-this.top() ) ;
    }
    moveCheck(obj) {
        if ( obj instanceof Stone ) {
            this.isAlive = false ;
            return false ;
        }
        return true ;
    }
}

class World {
    objects = [] ;
    constructor() {
    }

    process() {
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.beforeProcess() ;
            }
        }      
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj._process() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.afterProcess() ;
            }
        }      
        this.paint();
    }

    paint() {
        //console.log(objects.length);
        this.drawBackground();
        for( let i=0; i<this.objects.length; i++ ) {
            let obj = this.objects[i] ;
            if (obj.isAlive ){
                obj.paint() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
    }

    drawBackground(){
        ctx.fillStyle = `rgb(255,255,255)` ;
        ctx.fillRect( 0, 0, CELL_SIZE*TOTAL_COLS, CELL_SIZE*TOTAL_ROWS ) ;

        ctx.beginPath();
        ctx.strokeStyle = "orange";
        for (let i=0;i<TOTAL_COLS+1;i++){
            ctx.moveTo(CELL_SIZE*i,0 );
            ctx.lineTo(CELL_SIZE*i,CELL_SIZE*TOTAL_ROWS);
        } 
        for (let j=0;j<TOTAL_ROWS+1;j++){
            ctx.moveTo(0,CELL_SIZE*j );
            ctx.lineTo(CELL_SIZE*TOTAL_COLS, CELL_SIZE*j );    
        }
        ctx.stroke();
    }

    add( obj ) {
        let objs = this.overlapObjects(obj) ;
        for( let i=0; i<objs; i++ ) {
            objs[i].touched(obj) ;
            if ( !obj.moveCheck(objs[i]) ) {
                return false;
            }
        }
        if ( obj.isAlive ) {
            this.objects.push( obj ) ;
            return true ;
        }
        return false ;
    }

    overlapObjects(obj) {
        let objs = [] ;
        for( let i=0; i<this.objects.length; i++ ) {
            let obj2 = this.objects[i] ;
            if ( obj == obj2 ) {
                continue ;
            }
            if ( obj.right() <= obj2.left() ) {
                continue ;
            }
            if ( obj.top() >= obj2.bottom() ) {
                continue ;
            }
            if ( obj.left() >= obj2.right() ) {
                continue ;
            }
            if ( obj.bottom() <= obj2.top() ) {
                continue ;
            }
            objs.push( obj2 ) ;
        }
        return objs ;
    }
}
//============================================================================
//============================================================================
//============================================================================

function run(time) {
    if (!isRunning){
        return ;
    }

    if (lastTime === 0) {
        lastTime = time;
    }

    // 計算自上次更新以來經過的時間
    const deltaTime = time - lastTime
    if ( deltaTime > 30 ) {
        world.process();
        lastTime = time ;
    }
    requestAnimationFrame(run);

}

//----------------------------------------------------------------------
const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');    

const TOTAL_ROWS = 35 ;
const TOTAL_COLS = 35 ;
const CELL_SIZE = 15 ;
const WORLD_WIDTH = TOTAL_COLS*CELL_SIZE ;
const WORLD_HEIGHT = TOTAL_ROWS*CELL_SIZE;
let lastTime = 0 ;

let world = new World() ; 
world.add( new MyTank(30,30,0) ) ;
world.add( new MyTank(300, 400, 2) ) ;
world.add( new Stone(15*10, 15*20) ) ;
world.add( new Stone(15*12, 15*25) ) ;
world.add( new Stone(15*18, 15*10) ) ;
world.add( new Stone(15*8, 15*30) ) ;
let isRunning = true ;

requestAnimationFrame(run);

</script>