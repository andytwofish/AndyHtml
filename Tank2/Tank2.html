<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tank2</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
  <canvas id="_Canvas" width="560" height="560"></canvas>
</body>
</html>

<script>

class DrawableObject {
    isAlive = true ;
    isProcessed = false ;
    isMoved = false ;
    x = 0 ;
    y = 0 ;
    dir = 0 ;
    width=0;
    height=0;
    beforeProcess() {
        this.isProcessed = false ;
        this.isMoved = false ;
    }
    _process() {
        if ( this.isProcessed ) {
            return ;
        }
        this.process();
        this.isProcessed = true ;
    }
    process() {}
    moveTo( newX, newY ) {
        this.isMoved = true ;
        let oldX = this.x ;
        let oldY = this.y ;
        this.x = newX ;
        this.y = newY ;
        let objs = world.overlapObjects(this) ;
        for( let i=0; i<objs; i++ ) {
            objs[i].touched(this) ;
            if ( !this.moveCheck(objs[i]) ) {
                this.x = x ;
                this.y = y ;
                this.isMoved = false ;
            }
        }
    }
    afterProcess() { }
    paint() {}
    moveCheck(obj) {}
    touched(obj) {}
}

class MyTank extends DrawableObject {
    gamepadIdx= 0;
    delayCount=0;
    height=50;
    width=30;
    dir=0;
    constructor(gamepadIdx) {
        super() ;
        this.gamepadIdx = gamepadIdx ;
        this.x = (20+gamepadIdx)*CELL_SIZE ;
        this.y = 30 ;
    }
    paint() {
        ctx.fillStyle = `rgb(0,255,255)` ;
        if ( dir == 0 || dir == 180 ) {
            ctx.fillRect( this.x+this.width/2, this.y+this.height/2, this.width, this.height ) ;
        } else {
            ctx.fillRect( this.x+this.height/2, this.y+this.width/2, this.height, this.width ) ;
        }
    }
    process() {
        if ( this.delayCount++ > 1 ) {
            this.delayCount=0;
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[this.gamepadIdx] ;
            if (gamepad) {
                if ( gamepad.axes[0] == 1 ) {
                    //console.log("right") ;
                    this.keyRight();
                }
                if ( gamepad.axes[0] == -1 ) {
                    //console.log("left") ;
                    this.keyLeft();
                }
                if ( gamepad.axes[1] == 1 ) {
                    //console.log("down") ;
                    this.keyDown();
                }
                if ( gamepad.axes[1] == -1 ) {
                    //console.log("up") ;
                    this.keyUp() ;
                }
                if ( gamepad.buttons[0].pressed ) {
                    //console.log("space") ;
                    this.keySpace();  
                }
            }
        }
    }
    keyUp() {
        this.dir = 0 ;
        if ( this.x > 0 ) {
            this.moveTo( newX, newY-10 ) ;
        }
    }
    keyDown() {
        this.dir = 180 ;
        if ( this.row < TOTAL_ROWS-1 ) {
            this.moveTo(  newX, newY+10 ) ;
        }
    }
    keyRight() {
        this.dir = 90 ;
        if ( this.col < TOTAL_COLS-1 ) {
            this.moveTo( newX+10, newY ) ;
        }
    }
    keyLeft() {
        this.dir = 270;
        if ( this.col > 0 ) {
            this.moveTo( newX-10, newY ) ;
        }
    }
    keySpace() {
        world.add( new Bullet(this.x,this.y, this.dir) );
    }
    moveCheck(obj) {
    }
}

class Bullet extends DrawableObject {
    dist = 10 ;
    width=5;
    height=10;
    constructor(x,y,dir) {
        super();
        this.x = x ;
        this.y = y ;
        this.dir = dir ;
    }
    
    process() {
        if ( this.dist-- <=0 ) {
            this.isAlive = false ;
            return ;
        }
        switch( this.dir ) {
            case 0:
                world.move( this.x, this.y-10, this )  ;
                break;
            case 90:
                world.move( this.x+10, this.y, this )  ;
                break;
            case 180:
                world.move( this.x, this.y+10, this )  ;
                break;
            case 270:
                world.move( this.x-10, this.y, this )  ;
                break;
        }
    }
    paint(){
        ctx.fillStyle = `rgb(0,0,255)` ;
        if ( dir == 0 || dir == 180 ) {
            ctx.fillRect( this.x+this.width/2, this.y+this.height/2, this.width, this.height ) ;
        } else {
            ctx.fillRect( this.x+this.height/2, this.y+this.width/2, this.height, this.width ) ;
        }
    }
    moveCheck(obj) {
    }
}

class World {
    objects = [] ;
    constructor() {
    }

    process() {
        for( let i=0; i<objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.beforeProcess() ;
            }
        }      
        for( let i=0; i<objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj._process() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
        for( let i=0; i<objects.length; i++ ) {
            let obj = this.objects[i] ;
            if ( obj.isAlive ){
                obj.afterProcess() ;
            }
        }      
        this.paint();
    }

    paint() {
        //console.log(objects.length);
        this.drawBackground();
        for( let i=0; i<objects.length; i++ ) {
            let obj = this.objects[i] ;
            if (obj.isAlive ){
                obj.paint() ;
            } else {
                this.objects.splice(i--,1) ;
            }
        }      
    }

    drawBackground(){
        ctx.fillStyle = `rgb(255,255,255)` ;
        ctx.fillRect( 0, 0, CELL_SIZE*TOTAL_COLS, CELL_SIZE*TOTAL_ROWS ) ;

        ctx.beginPath();
        ctx.strokeStyle = "orange";
        for (let i=0;i<TOTAL_COLS+1;i++){
            ctx.moveTo(CELL_SIZE*i,0 );
            ctx.lineTo(CELL_SIZE*i,CELL_SIZE*TOTAL_ROWS);
        } 
        for (let j=0;j<TOTAL_ROWS+1;j++){
            ctx.moveTo(0,CELL_SIZE*j );
            ctx.lineTo(CELL_SIZE*TOTAL_COLS, CELL_SIZE*j );    
        }
        ctx.stroke();
    }

    add( obj ) {
        let objs = this.overlapObjects(obj) ;
        for( let i=0; i<objs; i++ ) {
            objs[i].touched(obj) ;
            if ( !obj.moveCheck(objs[i]) ) {
                return false;
            }
        }
        if ( obj.isAlive ) {
            this.objects.push( obj ) ;
            return true ;
        }
        return false ;
    }

    overlapObjects(obj) {
        return [] ;
    }
}
//============================================================================
//============================================================================
//============================================================================

function run(time) {
    if (!isRunning){
        return ;
    }

    if (lastTime === 0) {
        lastTime = time;
    }

    // 計算自上次更新以來經過的時間
    const deltaTime = time - lastTime
    if ( deltaTime > 30 ) {
        world.process();
        lastTime = time ;
    }
    requestAnimationFrame(run);

}

//----------------------------------------------------------------------
const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');    

const TOTAL_ROWS = 35 ;
const TOTAL_COLS = 35 ;
const CELL_SIZE = 15 ;
const WORLD_WIDTH = TOTAL_COLS*CELL_SIZE ;
const WORLD_HEIGHT = TOTAL_ROWS*CELL_SIZE;
let lastTime = 0 ;

let world = new World() ; 
world.add( new MyTank(0) ) ;
world.add( new MyTank(1) ) ;
let isRunning = true ;

requestAnimationFrame(run);

</script>