<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>演化模擬</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
  <canvas id="_Canvas" width="800" height="800"></canvas>
  <img id="frogImg" src="./frog.png" alt="Source Image" style="display:none;">
  <DIV id="display" style="border: 1px solid #000;position: absolute; width: 130px; height: 80px; background-color: white;top: 10px;left: 10px;">test test</DIV>
</body>
</html>

<script>
//=============================
//==========  class ===========
//=============================
class Tree {
  deadFrequency=0 ;
  static GROW_UP_HEIGHT = 10 ;
  static BORN_PROBABILITY = 0.25 ;
  static INIT_HEIGHT = 50 ;
  nowHeight = Tree.INIT_HEIGHT ; 
  limitHeight ; //亂數100~300
    constructor() {
    this.limitHeight = 100 + Math.floor( Math.random()*201 );
  }

  nextRun(){
    this.nowHeight=this.nowHeight+Tree.GROW_UP_HEIGHT;
    if (this.nowHeight>this.limitHeight){
      this.nowHeight=this.limitHeight ;
    }
  }
 

}
class Deer {
  isMale ;
  heigh ;  //短100cm , 高200cm 
}

class World {
  static nextRun() {
    for (let row=0; row<WORLD_ROWS;row++) {
      for (let col=0; col<WORLD_COLS;col++) {
        if( matrix[row][col] instanceof Tree){
          matrix[row][col].nextRun();
          World.treeDeadRule(row, col);
        } 
      }
    }
    World.bornTrees();
  }

  static treeDeadRule( row, col) {
    let trees = World.getTreesAround( row, col ) ;
    let deadTree=0
    for( let j=0; j<trees.length; j++ ) {
      if (trees[j].nowHeight>matrix[row][col].nowHeight){
        deadTree=deadTree+1;
        }
    }
    if (deadTree>=3){  
     matrix[row][col].deadFrequency+=1;
    } else {
      matrix[row][col].deadFrequency=0
    }

    if (matrix[row][col].deadFrequency>=3){
     matrix[row][col] =0;
    }
  }

  //傳回空地周圍九宮格的樹陣列
  static getTreesAround( row, col ) {
    let trees = [] ;
    for( let j=-1; j<2; j++ ) {
      for( let i=-1; i<2; i++ ) {
        if ( matrix[row+j][col+i] instanceof Tree ) {
          trees[trees.length] =  matrix[row+j][col+i] ;
        }
      }
    }
    return trees ;
  }

  //傳回空地周圍九宮格的老樹陣列
  static getOldTreesAound( row, col ) {
    let trees = World.getTreesAround( row, col ) ;
    for( let i=0; i<trees.length; i++ ) {
      if ( trees[i].nowHeight == Tree.INIT_HEIGHT ) {
        trees.splice(i,1) ;
        i--;
      }
    }
    return trees ;
  }

  static bornTrees() {
    for (let row=1; row<WORLD_ROWS-1;row++) {
      for (let col=1; col<WORLD_COLS-1;col++) {
        if( matrix[row][col] == 0 ){
          let trees = World.getOldTreesAound( row, col ) ;
          let random = Math.floor( 1+Math.random()*8 );  //return 1~8
          if ( random <= trees.length ) {
            //要種了
            let random2 = Math.floor( Math.random()*trees.length ); 
            matrix[row][col] = new Tree() ;
            matrix[row][col].limitHeight = trees[random2].limitHeight ;
          }
        } 
      }
    }
  }

  static drawWorld() {
    cleanScreen();
    drawCells();
    //
    for(let row=0; row<WINDOW_ROWS;row++) {
      for(let col=0; col<WINDOW_COLS;col++) {
        if( matrix[row][col] instanceof Tree){
            ctx.fillStyle = `rgb(0,${255-matrix[row][col].nowHeight},0)` ;
            ctx.fillRect(col*CELL_SIZE+1,row*CELL_SIZE+1,
                 CELL_SIZE-2, CELL_SIZE-2 ) ;
        }
      }
    }
  }
}

//=============================
//==========  function ===========
//=============================

function cleanScreen() {
    ctx.fillStyle = `rgb(255,255,255)` ;
    ctx.fillRect(0,0,canvas.width, canvas.height) ;
}

//畫出螢幕上的格子
function drawCells() {
  ctx.beginPath() ;
  ctx.lineWidth = 2;
  ctx.strokeStyle = "orange";

  for (let j=0; j<WINDOW_ROWS+1;j++) {
    ctx.moveTo(0,CELL_SIZE*j);
    ctx.lineTo( CELL_SIZE*WINDOW_COLS,CELL_SIZE*j);
  }
  for (let j=0; j<WINDOW_COLS+1;j++) {
    ctx.moveTo(CELL_SIZE*j,0 );
    ctx.lineTo(CELL_SIZE*j,CELL_SIZE*WINDOW_ROWS);
  }
  ctx.stroke();
}

function drawFrog(row, col) {
  let img = document.getElementById('frogImg');
  ctx.drawImage(img, col*CELL_SIZE, row*CELL_SIZE ); 
}

//檢查空地，周圍九宮格是否有樹，有的話回傳true否則回傳false
function haveTreeAound( row, col ) {
  for( let j=-1; j<2; j++ ) {
    for( let i=-1; i<2; i++ ) {
      if ( matrix[row+j][col+i] instanceof Tree ) {
        return true ;
      }
    }
  }
}

//檢查所有空地，看看是否要生出小樹
function bornTree() {
}

window.onload = function() {
  drawCells() ;
  drawFrog(5,5) ;
  drawFrog(5,45) ;
  drawFrog(45,5) ;
  drawFrog(45,45) ;
  drawFrog(25,25) ;
}

function keydownEvent(event) {
    switch(event.code) {
        case 'Space':
            World.nextRun() ;
            //console.log( matrix ) ;
            World.drawWorld();
            displayInfo(lastInfoRow, lastInfoCol) ;
            break;
        }
}

function displayInfo(row, col) {
    let panel = document.getElementById('display') ;
    const rect = canvas.getBoundingClientRect();
    panel.style.top = `${event.clientY-rect.top}px` ;
    panel.style.left = `${event.clientX-rect.left+30}px`;
    panel.innerText="";
    if ( row >= WINDOW_ROWS || col >= WINDOW_COLS ) {
        return;
    }
    if ( matrix[row][col] instanceof Tree ) {
        panel.innerHTML = `Tree:<BR>Height:${matrix[row][col].nowHeight}<BR>LimitHeight:${matrix[row][col].limitHeight}`;
    } 
    lastInfoRow = row ;
    lastInfoCol = col ;
}

function mouseEvent(event) {
    const rect = canvas.getBoundingClientRect();
    let row = Math.floor( (event.clientY-rect.top) / CELL_SIZE) ;
    let col = Math.floor( (event.clientX-rect.left) / CELL_SIZE) ;
    displayInfo(row, col) ;
}


//===========================================
// ============= 主程式 =====================
//===========================================
const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 14;
const WINDOW_ROWS = 50;
const WINDOW_COLS = 50;
const WORLD_ROWS = 50;
const WORLD_COLS = 50;

let lastInfoRow = 0 ;
let lastInfoCol = 0 ;

//初始化matrix陣列，每個陣列可能是鹿或樹
let matrix = [] ; 
for( let row=0; row<WORLD_ROWS; row++ ) {
  matrix[row] = [];
  for( let col=0; col<WORLD_COLS; col++ ) {
    matrix[row][col] = 0 ;
  }
}
matrix[5][5] = new Tree() ;
matrix[5][45] = new Tree() ;
matrix[45][5] = new Tree() ;
matrix[45][45] = new Tree() ;
matrix[25][25] = new Tree() ;
console.log( "haveTreeAround(4,4):" + haveTreeAound(4,4) );
console.log( "haveTreeAround(6,6):" + haveTreeAound(6,6) );
console.log( matrix[4][3].limitHeight ) ;

console.log( matrix ) ;

document.addEventListener("keydown", keydownEvent );
canvas.addEventListener("mousemove", mouseEvent ) ;
canvas.style.cursor = "pointer";


// ====== Example  ======
let andyHeigh =0;
let name = "Andy Lin";
for ( let i=0; i<10; i++ ) {
}

function coord( row, col) {
  return row*10+col;
}

let ret = coord( 3, 4) ;
console.log( "ret=" + ret ) ;

let abc = [] ;
abc[0] = 0;
abc[1] = 2;
console.log(abc) ;

class Frog {
  color = "red" ;
  jump(step) {
    console.log( "jump="+ step ) ;
  }
}

let frog1 = new Frog() ;
console.log( frog1.color ) ;
frog1.color = "black" ;
console.log( frog1.color ) ;
frog1.jump(5) ;

let frog2 = new Frog() ;
console.log( frog2 ) ;


// =============================================
 
</script>