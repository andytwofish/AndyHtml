<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>演化模擬</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
  <canvas id="_Canvas" width="800" height="400"></canvas>
  <img id="frogImg" src="./frog.png" alt="Source Image" style="display:none;">
</body>
</html>

<script>
//=============================
//==========  class ===========
//=============================
class Tree {
  static GROW_UP_HEIGHT = 10 ;
  static BORN_PROBABILITY = 0.25 ;
  nowHeigh = 50 ; 
  limitHeight ; //亂數100~300
  lackSunLightCount = 0 ; //大於4次則死
  constructor() {
    this.limitHeight = 100 + Math.floor( Math.random()*201 );
  }

  nextRun(){
    this.nowHeigh=this.nowHeigh+GROW_UP_HEIGHT;
    if (this.nowHeigh>this.limitHeight){
      this.nowHeigh=this.limitHeight ;
    }
  }
 

}
class Deer {
  isMale ;
  heigh ;  //短100cm , 高200cm 
}

class World {
  static nextRun() {

  }
}

let t = new Tree() ;
let d = new Deer() ;
console.log( t instanceof Tree ) ;
console.log( t instanceof Deer ) ;

//=============================
//==========  function ===========
//=============================
//畫出螢幕上的格子
function drawCells() {
  ctx.beginPath() ;
  ctx.lineWidth = 2;
  ctx.strokeStyle = "orange";

  for (let j=0; j<WINDOW_ROWS+1;j++) {
    ctx.moveTo(0,CELL_SIZE*j);
    ctx.lineTo( CELL_SIZE*WINDOW_COLS,CELL_SIZE*j);
  }
  for (let j=0; j<WINDOW_COLS+1;j++) {
    ctx.moveTo(CELL_SIZE*j,0 );
    ctx.lineTo(CELL_SIZE*j,CELL_SIZE*WINDOW_ROWS);
  }
  ctx.stroke();
}

function drawFrog(row, col) {
  let img = document.getElementById('frogImg');
  ctx.drawImage(img, col*CELL_SIZE, row*CELL_SIZE ); 

}
//傳回空地周圍九宮格樹的陣列
function getTreesAound( row, col ) {
  let trees = [] ;
  for( let j=-1; j<2; j++ ) {
    for( let i=-1; i<2; i++ ) {
      if ( matrix[row+j][col+i] instanceof Tree ) {
        trees[trees.length] =  matrix[row+j][col+i] ;
      }
    }
  }
  return trees ;
}

//檢查空地，周圍九宮格是否有樹，有的話回傳true否則回傳false
function haveTreeAound( row, col ) {
  for( let j=-1; j<2; j++ ) {
    for( let i=-1; i<2; i++ ) {
      if ( matrix[row+j][col+i] instanceof Tree ) {
        return true ;
      }
    }
  }
}

//檢查所有空地，看看是否要生出小樹
function bornTree() {
}

window.onload = function() {
  console.log("Hi Befoo");
  drawCells() ;
  drawFrog(3,2) ;
  drawFrog(4,3) ;
}

// ==== 全域變數 ===============================
const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 14;
const WINDOW_ROWS = 20;
const WINDOW_COLS = 50;
const WORLD_ROWS = 100;
const WORLD_COLS = 100;

//初始化matrix陣列，每個陣列可能是鹿或樹
let matrix = [] ; 
for( let row=0; row<WORLD_ROWS; row++ ) {
  matrix[row] = [];
  for( let col=0; col<WORLD_COLS; col++ ) {
    matrix[row][col] = 0 ;
  }
}
matrix[3][2] = new Tree() ;
matrix[4][3] = new Tree() ;
console.log( "haveTreeAround(4,4):" + haveTreeAound(4,4) );
console.log( "haveTreeAround(6,6):" + haveTreeAound(6,6) );
console.log( matrix[4][3].limitHeight ) ;
console.log( matrix ) ;

let trees = getTreesAound(4,4) ;
console.log( trees ) ;

for( let i=0; i<1; i++ ) {
  World.nextRun() ;
}
console.log( matrix ) ;
// ====== Example  ======
let andyHeigh =0;
let name = "Andy Lin";
for ( let i=0; i<10; i++ ) {
}

function coord( row, col) {
  return row*10+col;
}

let ret = coord( 3, 4) ;
console.log( "ret=" + ret ) ;

let abc = [] ;
abc[0] = 0;
abc[1] = 2;
console.log(abc) ;

class Frog {
  color = "red" ;
  jump(step) {
    console.log( "jump="+ step ) ;
  }
}

let frog1 = new Frog() ;
console.log( frog1.color ) ;
frog1.color = "black" ;
console.log( frog1.color ) ;
frog1.jump(5) ;

let frog2 = new Frog() ;
console.log( frog2 ) ;


// =============================================
 
</script>