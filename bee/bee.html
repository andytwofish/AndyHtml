<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>bee</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
    <canvas id="_Canvas" width="560" height="560"></canvas>
    <img id="babyTankImg" src="./icons8-alien-monster-94.png" alt="Source Image" style="display:none;">
    <img id="M.shieldImg" src="./icons8-shield-48 2.png" alt="Source Image" style="display:none;">
    <img id="E.shieldImg" src="./icons8-shield-48.png" alt="Source Image" style="display:none;">
    <img id="tankImg" src="./icons8-tank-16.png" alt="Source Image" style="display:none;">
    <img id="M.tankImg" src="./icons8-tank-top-view-50 1.png" alt="Source Image" style="display:none;">
    <img id="peopleImg" src="./icons8-top-view-man-48 1.png" alt="Source Image" style="display:none;">
    <img id="M.bulletImg" src="./icons8-bullet-64.png" alt="Source Image" style="display:none;">
    <img id="E.bulletImg" src="./icons8-bullet-24.png" alt="Source Image" style="display:none;">
    <img id="firstaidkit" src="./icons8-organ-transplantation-24.png" alt="Source Image" style="display:none;">
    <img id="diode" src="./icons8-led-diode-48.png" alt="Source Image" style="display:none;">
    <img id="lightImg" src="./—Pngtree—light effect of lightning blue_6183369.png" alt="Source Image" style="display:none;">
</body>
</html>

<script>

const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');     

class Coord {
    row=0;
    col=0;
    constructor( row, col ) {
        this.row = row ;
        this.col = col ;
    }
}

class Boundary {
    top = 0 ;
    bottom = 0 ;
    left = 0 ;
    right = 0 ;
}

class Part {
    coords = [] ;
    hp = 1 ;
    fillStyle = `rgb(100,100,100)` ;
    boundary = new Boundary() ;

    updateBoundary( coord ) {
        if ( coord.col > 0 && coord.col > this.boundary.right ) {
            this.boundary.right = coord.col ;
        }
        if ( coord.col < 0 && coord.col < this.boundary.left ) {
            this.boundary.left = coord.col ;
        }
        if ( coord.row > 0 && coord.row > this.boundary.bottom ) {
            this.boundary.bottom = coord.row ;
        }
        if ( coord.row < 0 && coord.row < this.boundary.top ) {
            this.boundary.top = coord.row ;
        }
    }

    add(row,col) {
        let coord = new Coord() ;
        coord.row = row ;
        coord.col = col ;
        this.coords.push( coord ) ;
        this.updateBoundary( coord ) ;
        return this ;
    }
}

class Entity {
    static objs = [] ;
    static DirectionMap = [0, 90, 180, 270] ;
    hp = 1 ;
    spaceBoundary = new Boundary() ;
    moveDistance = 0 ;
    moveDelayTime = 100 ;
    moveDirection = 0 ;


    constructor( coord, rotation ) {
        this.rotation = rotation ;
        this.coord = coord ;
        this.spaceBoundary.top = 0;
        this.spaceBoundary.bottom = TOTAL_ROWS-1;
        this.spaceBoundary.left = 0;
        this.spaceBoundary.right = TOTAL_COLS-1;
        this.init() ;
        Entity.objs.push( this ) ;
    }

    init() {
        let part0 = new Part() ;
        part0.add(0,0) ;
        part0.fillStyle = "rgb(100,0,0)" ;

        let part1 = new Part() ;
        part1.add(0,-1).add(0,1).add(0,2).add(0,-2) ;

        this.parts = [] ;
        this.parts.push( part0 ) ;
        this.parts.push( part1 ) ;
    }

    moveCheck( row, col ) {
        let entityBoundary = this.findEntityBoundary() ;
        if ( row+entityBoundary.top < this.spaceBoundary.top || row+entityBoundary.bottom > this.spaceBoundary.bottom ) {
            return false ;
        }
        if ( col+entityBoundary.left < this.spaceBoundary.left || col+entityBoundary.right > this.spaceBoundary.right ) {
            return false ;
        }
        return true ;
    }

    moveIfPermitted( row, col ) {
        if ( this.moveCheck(row, col ) ) {
            this.coord.row = row ;
            this.coord.col = col ;
            return true ;
        }
        return false ;
    }

    getRandomLocation() {
        let coord = new Coord() ;
        while( true ) {
            coord.row = Math.floor(Math.random()* (this.spaceBoundary.bottom-this.spaceBoundary.top) )+this.spaceBoundary.top ;  
            coord.col = Math.floor(Math.random()* (this.spaceBoundary.rightm-this.spaceBoundary.left) )+this.spaceBoundary.left ; 
            if ( this.moveCheck( coord.row, coord.col ) ) {
                break;
            }
        }
        return coord ;
    }

    findEntityBoundary() {
        let boundary = new Boundary() ;
        for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
            if ( this.parts[partIdx].hp <= 0 ) {
                continue ;
            }
            let partBoundary = this.parts[partIdx].boundary ;
            if ( partBoundary.right > boundary.right ) {
                boundary.right = partBoundary.right ;
            }
            if ( partBoundary.left < boundary.left ) {
                boundary.left = partBoundary.left ;
            }
            if ( partBoundary.top < boundary.top ) {
                boundary.top = partBoundary.top ;
            }
            if ( partBoundary.bottom > boundary.bottom ) {
                boundary.bottom = partBoundary.bottom ;
            }
        }
        return boundary ;
    }

    draw(){
        for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
            if ( this.parts[partIdx].hp <= 0 ) {
                continue ;
            }
            ctx.fillStyle = this.parts[partIdx].fillStyle ;
            for ( let i=0; i<this.parts[partIdx].coords.length; i++ ) {
                let coord = this.parts[partIdx].coords[i] ;
                ctx.fillRect( (this.coord.col+coord.col)*CELL_SIZE+1, (this.coord.row+coord.row)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            }
        }
    }

    attackedPart( fromEntity, partIdx) {
        this.hp--;
    }

    attackCheck( fromEntity ) {
        for( let fromPartIdx=0; fromPartIdx<fromEntity.parts.length; fromPartIdx++ ) {
            let fromPart = fromEntity.parts[fromEntity] ;
            if ( fromPart.hp <= 0 ) {
                continue ;
            }
            //初步比較
            if ( this.boundary.right < fromEntity.boundary.left ) {
                return false ;
            }
            if ( this.boundary.top > fromEntity.boundary.bottom ) {
                return false ;
            }
            if ( this.boundary.left > fromEntity.boundary.right ) {
                return false ;
            }
            if ( this.boundary.bottom < fromEntity.boundary.top ) {
                return false ;
            }

            //細部每個cell比較
            for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
                let toPart = this.parts[partIdx] ;
                if ( toPart.hp <= 0 ) {
                    continue ;
                }
                for ( let i=0; i<fromPart.coords.length; i++ ) {
                    let fromCoord = fromPart.coords[i] ;
                    for ( let j=0; j<toPart.coords.length; j++ ) {
                        let toCoord = toPart.coords[j] ;
                        if ( fromEntity.coord.row+fromCoord.row == this.coord.row+toCoord.row 
                            && fromEntity.coord.col+fromCoord.col == this.coord.col+toCoord.col ) {
                            this.attackedPart( fromEntity, partIdx ) ;
                            return true ;
                        }
                    }
                }
            }
        }
        return false ;
    }

    process(){
        this.move() ;
        this.draw() ;
    }
}

class SuperBullet extends Entity {
    createFrom = 0 ;
    moveDistance = 100 ;
    constructor( coord, rotation, createFrom ) {
        super( coord, rotation ) ;
        this.createFrom = createFrom ;
        this.moveDirection = rotation ;
    }
    init() {
        let part0 = new Part() ;
        part0.add(0,0) ;
        part0.fillStyle = "rgb(200,0,0)" ;

        this.parts = [] ;
        this.parts.push( part0 ) ;
    }
   move() {
        if ( this.moveDistance-- > 0 )  {
            let isMove = false ;
            switch( this.moveDirection ) {
                case 0:
                    isMove = this.moveIfPermitted( this.coord.row-1, this.coord.col ) ;
                    break;
                case 90:
                    isMove = this.moveIfPermitted( this.coord.row, this.coord.col+1 ) ;
                    break;
                case 180:
                    isMove = this.moveIfPermitted( this.coord.row+1, this.coord.col ) ;
                    break;
                case 270:
                    isMove = this.moveIfPermitted( this.coord.row, this.coord.col-1 ) ;
                    break;
            }
            if ( !isMove ) {
                this.hp = 0 ;
            }
        } else {
            this.hp = 0 ;
        }

    }

}

class OurTank extends Entity {
    lastFireTS = Date.now() ;
    lastMoveTS = Date.now() ;
    stopTime = 10000 ; //移動完停多久
    constructor( coord, rotation ) {
        super( coord, rotation ) ;
    }
    move() {
        if ( this.moveDistance-- <= 0 ) {
            if (Date.now() - this.lastMoveTS > this.stopTime ) {
                this.moveDistance = Math.floor( Math.random() * 20 ) ;
                this.moveDirection = Entity.DirectionMap[ Math.floor( Math.random() * 4 ) ];
                console.log(`新方向 ${this.moveDirection}, ${this.moveDistance}`);
            }
            return ;
        }
        let isMove = false ;
        switch( this.moveDirection ) {
            case 0:
                isMove = this.moveIfPermitted( this.coord.row-1, this.coord.col ) ;
                break;
            case 90:
                isMove = this.moveIfPermitted( this.coord.row, this.coord.col+1 ) ;
                break;
            case 180:
                isMove = this.moveIfPermitted( this.coord.row+1, this.coord.col ) ;
                break;
            case 270:
                isMove = this.moveIfPermitted( this.coord.row, this.coord.col-1 ) ;
                break;
        }
        if ( isMove ) {
            this.lastMoveTS = Date.now() ;
        } else {
            this.moveDistance = 0 ;
        }

    }
    process() {
        super.process() ;
        if ( Date.now() - this.lastFireTS > 1000 ) {
            this.lastFireTS = Date.now() ;
            console.log("產生子彈");
            new SuperBullet(this.coord, 0, this) ;
        }

    }
}

class Tank{
    static directionMap = [0, 90, 180, 270] ;
    hp = 3 ;
    row = Math.floor(Math.random()*19) ;  
    col = Math.floor(Math.random()*39) ; 
    lastFireTS = 0 ;
    constructor() {
        this.init() ;
        this.rollTheDice() ;
    }

    init() {
        let part0 = new Part() ;
        part0.add(0,0) ;

        let part1 = new Part() ;
        part1.add(0,-1).add(0,1).add(0,2).add(0,-2) ;

        this.parts = [] ;
        this.parts.push( part0 ) ;
        //this.parts.push( part1 ) ;
    }

    getBoundary() {
        let boundary = new Boundary() ;
        for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
            if ( this.parts[partIdx].hp <= 0 ) {
                continue ;
            }
            for ( let i=0; i<this.parts[partIdx].coords.length; i++ ) {
                let coord = this.parts[partIdx].coords[i] ;
                if ( coord.col > 0 && coord.col > boundary.right ) {
                    boundary.right = coord.col ;
                }
                if ( coord.col < 0 && coord.col < boundary.left ) {
                    boundary.left = coord.col ;
                }
                if ( coord.row > 0 && coord.row > boundary.bottom ) {
                    boundary.bottom = coord.row ;
                }
                if ( coord.row < 0 && coord.row < boundary.top ) {
                    boundary.top = coord.row ;
                }

            }
        }
        return boundary ;
    }

    autoDraw() {
        for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
            if ( this.parts[partIdx].hp <= 0 ) {
                continue ;
            }
            ctx.fillStyle = this.parts[partIdx].fillStyle ;
            for ( let i=0; i<this.parts[partIdx].coords.length; i++ ) {
                let coord = this.parts[partIdx].coords[i] ;
                ctx.fillRect( (this.col+coord.col)*CELL_SIZE+1, (this.row+coord.row)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            }
        }
    }

    draw(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "tankImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 180 ) ;
    }

    attackedPart(partIdx) {
        this.hp--;
    }
    //傳入被攻的位置，
    //傳出boolean  true:有打到  false:沒打到
    attack( row, col ) {
        for( let partIdx=0; partIdx<this.parts.length; partIdx++ ) {
            if ( this.parts[partIdx].hp <= 0 ) {
                continue ;
            }
            for ( let i=0; i<this.parts[partIdx].coords.length; i++ ) {
                let coord = this.parts[partIdx].coords[i] ;
                if ( row == this.row+coord.row && col == this.col+coord.col ) {
                    this.attackedPart(partIdx) ;
                    return true ;
                }
            }
        }
        return false ;
    }

    rollTheDice() {
        this.distance = Math.floor(Math.random()*8) ; 
        this.direction = Tank.directionMap[Math.floor(Math.random()*4)] ;
        this.moveDelayCount = Math.floor(Math.random()*4)*3+3 ; 
    }

    move() {
        if ( this.distance-- < 0 && this.moveDelayCount-- <= 0 ) {
            this.rollTheDice() ;
        }
        if ( this.distance < 0 ) {
            return ;
        }
        let boundary = this.getBoundary() ;
        switch( this.direction ) {
            case 0:
                if ( this.row+boundary.top-1 >= 0 ) {
                    this.row-=1 ;
                }
                break;
            case 90:
                if ( this.col+boundary.right+1 <= TOTAL_COLS-1 ) {
                    this.col+=1 ;
                }
                break;
            case 180:
                if ( this.row+boundary.bottom+1 <= 19 ) {
                    this.row+=1;
                }
                break;
            case 270:
                if ( this.col+boundary.left-1 >= 0 ) {
                    this.col-=1;
                }
                break;
        }
    }

    process(){
        if ( Date.now() - this.lastFireTS > 1000 ) {
            this.lastFireTS = Date.now() ;
            tanks.push( new Bullet(this.row,this.col,this.red,this.green,this.blue) );
        }
        this.move() ;
        this.draw() ;
    }
}

class ShieldPeople extends Tank {
    lastShieldTS = 0 ;

    init() {
        let part0 = new Part() ;
        part0.add(0,0) ;

        let part1 = new Part() ;
        part1.add(1,-2).add(2,-1).add(2,0).add(2,1).add(1,2) ;

        this.parts = [] ;
        this.parts.push( part0 ) ;
        this.parts.push( part1 ) ;
    }

    draw(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "peopleImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 180 ) ;
    
        if ( this.parts[1].hp > 0 ){
            ctx.fillStyle = `rgb(100,100,0)` ;
            ctx.fillRect( (this.col-2)*CELL_SIZE+1, (this.row+1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col-1)*CELL_SIZE+1, (this.row+2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+1)*CELL_SIZE+1, (this.row+2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+2)*CELL_SIZE+1, (this.row+1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
            y = ((this.row+2)*CELL_SIZE+1) + CELL_SIZE/2 ;
            drawImg( "E.shieldImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 0 ) ;
        }   
    }

    attackedPart(partIdx) {
        if ( partIdx == 0) {
            this.hp = 0 ;
        } else if ( partIdx == 1 ) {
            this.parts[partIdx].hp-- ;
        }
    }

    process(){
        if (this.parts[1].hp > 0 ){
            this.lastShieldTS = Date.now() ;
        } else {
            if ( Date.now() - this.lastShieldTS > 3000 ) {
                this.parts[1].hp = 1 ;
            }
        }
        this.move() ;
        this.draw() ;
    }

}

class SuperTank extends Tank { 
    col = 5+Math.floor(Math.random()*29) ; 
    lastFireTS = 0 ;
    hp = 1 ;
    init() {
        let part0 = new Part() ;
        part0.add(0,0).add(0,-1).add(0,-2).add(0,-3).add(0,-4).add(0,1).add(0,2).add(0,3).add(0,4) ;
        part0.add(-1,0).add(-1,-1).add(-1,1) ;

        let part1 = new Part() ;
        part1.add(1,-4) ;

        let part2 = new Part() ;
        part2.add(1,-2) ;

        let part3 = new Part() ;
        part3.add(1,0) ;

        let part4 = new Part() ;
        part4.add(1,2) ;

        let part5 = new Part() ;
        part5.add(1,4) ;

        this.parts = [] ;
        this.parts.push( part0 ) ;
        this.parts.push( part1 ) ;
        this.parts.push( part2 ) ;
        this.parts.push( part3 ) ;
        this.parts.push( part4 ) ;
        this.parts.push( part5 ) ;
    }

    draw(){
        this.autoDraw() ;
    }

    attackedPart(partIdx) {
        if ( partIdx == 0) {
            this.hp = 0 ;
            for( let i=1; i<this.parts.length; i++) {
                if ( this.parts[i].hp > 0 ) {
                    this.hp = 1 ;
                }
            }
        } else {
            this.parts[partIdx].hp = 0 ;
        }
    }

    process(){
        if ( Date.now() - this.lastFireTS > 2800 ) {
            this.lastFireTS = Date.now() ;
            for( let i=1; i<this.parts.length; i++ ) {
                if ( this.parts[i].hp > 0 ) {
                    tanks.push( new Bullet(this.row+1,this.col+this.parts[i].coords[0].col,200,200,200) );
                }
            }
        }
        this.move() ;
        this.draw() ;
    }

}
class BigTank extends SuperTank{
    HIGHEST_HP = 4 ;
    hp = this.HIGHEST_HP ;
    lastFireTS = 2000 ;
    lastFireTS2 = 2000 ;
    init() {
        let part0 = new Part() ;
        part0.add(-2,0)
        let part1 = new Part() ;
        part1.add(0,0).add(-1,-1).add(-1,0).add(-1,1).add(0,-1).add(0,1).add(1,-1).add(1,0).add(1,1) ;
        part1.add(-1,-2).add(-1,2).add(-1,-3).add(-1,3).add(-1,-4).add(-1,4).add(1,-2).add(1,2).add(2,-2).add(2,2).add(3,-2).add(3,2).add(4,-1).add(4,1) ;

        let part2 = new Part() ;
        part2.add(2,0) ;
        part2.fillStyle = "rgb(200,0,0)" ;

        let part3 = new Part() ;
        part3.add(0,-4) ;

        let part4 = new Part() ;
        part4.add(0,4) ;
        this.parts = [] ;
        this.parts.push( part0 ) ;
        this.parts.push( part1 ) ;
        this.parts.push( part2 ) ;
        this.parts.push( part3 ) ;
        this.parts.push( part4 ) ;
    }
    attackedPart(partIdx) {
        if ( partIdx == 0) {
            this.hp-- ;
            for( let i=1; i<this.parts.length; i++) {
                if ( this.parts[i].hp > 0 ) {
                    this.hp = this.HIGHEST_HP ;
                }
            }
        } else {
            if ( partIdx == 1) {
                if (this.parts[2].hp<=0&&this.parts[3].hp<=0&&this.parts[4].hp<=0){
                    this.parts[partIdx].hp = 0 ;
                }else{
                    return ;
                }
            }
            this.parts[partIdx].hp = 0 ;
        }
    }
    process(){
        if ( Date.now() - this.lastFireTS > 2000 ) {
            this.lastFireTS = Date.now() ;
            if ( this.parts[3].hp > 0 ) {
                tanks.push( new Missile(this.row+1,this.col+this.parts[3].coords[0].col,200,200,200) );
            }
            if ( this.parts[4].hp > 0 ) {
                tanks.push( new Missile(this.row+1,this.col+this.parts[4].coords[0].col,200,200,200) );
            }
            if (this.parts[0].hp > 0 ){
                if (this.parts[1].hp <= 0){
                    tanks.push( new Missile(this.row+1,this.col+this.parts[0].coords[0].col,200,200,200) );
                    let random = target.length*(4+Math.floor(Math.random()*4)) ;
                    for (let i=0;i<random;i++){
                        let k = Math.floor(Math.random()*target.length) ;
                        let tankCol = target[k].col ;
                        let col = Math.floor(Math.random()*8)-4+tankCol ;
                        for (let j=0;j<TOTAL_ROWS;j++){
                            tanks.push( new LaserLight(0+j,col,200,200,200) );
                        }
                    }
                }
            }
        }
        if ( Date.now() - this.lastFireTS2 > 800 ) {
            this.lastFireTS2 = Date.now() ;
                if ( this.parts[2].hp > 0 ) {
                    for (let i=0;i<TOTAL_ROWS;i++){
                        tanks.push( new LaserLight(this.row+1+i,this.col+this.parts[1].coords[0].col,200,200,200) );
                    }
                }
        }
        this.move() ;
        this.draw() ;
    }
}
class BabyTank extends Tank {
    hp=2;
    draw(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "babyTankImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 0 ) ;
    }

    process(){
        if ( Math.floor(Math.random()*100)<=0 ) {
            tanks [tanks.length] = new Tank () ;
            tanks [tanks.length-1].row = this.row+=1 ;
            tanks [tanks.length-1].col = this.col ;
        }
        if ( Math.floor(Math.random()*100)<=0 ) {
            tanks [tanks.length] = new ShieldPeople () ;
            tanks [tanks.length-1].row = this.row+=1 ;
            tanks [tanks.length-1].col = this.col ;
        }

        this.move() ;
        this.draw() ;
    }

}


class Bullet{
    bullet = [] ;
    row = 0 ;
    col = 0 ;
    red = 0 ;
    green = 0 ;
    blue = 0 ;
    hp = 1 ;
    constructor(row,col,red,green,blue) {
        this.row = row ;
        this.col = col ;
        this.red = red ;
        this.green = green ;
        this.blue = blue ;
        //this.move();
    }
    
    process(){
        if ( this.hp==0 ) {
            return ;
        }
//        this.cleanBulletCell() ;
        this.row+=1 ;    
        if (this.row>39){
            this.hp=0 ; 
        } 
        
        this.drawBulletCell() ;
//        setTimeout( this.move.bind(this), 30 ) ;
        
    }
    drawBulletCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "M.bulletImg", x, y, CELL_SIZE, CELL_SIZE, 180 ) ;
    }
}
class Missile extends Bullet{
    run = 64 ;
    direction = 0 ;
    target2 = target[Math.floor(Math.random()*target.length)] ;
    process(){
        this.run-- ;
        if (this.run<1){
            this.hp = 0 ;
        }
        if ( this.hp==0 ) {
            return ;
        }
        if (Math.floor(Math.random()*2) == 0){
            if (this.row>this.target2.row){
                this.row-- ;
                this.direction = 0 ;
            }else{
                if(this.row<this.target2.row){
                    this.row++ ;
                    this.direction = 180 ;
                }
            }
        }else{
            if (this.col>this.target2.col){
                    this.col-- ;        
                    this.direction = 270 ;                           
            }else{
                if(this.col<this.target2.col){
                    this.col++ ;
                    this.direction = 90 ;
                }                                          
            }
        }
        
        this.drawBulletCell() ;  
    }
    drawBulletCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "diode", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, this.direction ) ;
    }
}
class LaserLight extends Bullet{
    hp = 7 ;
    process(){
        this.hp-- ;
        if ( this.hp<1 ) {
            return ;
        }
        this.drawBulletCell()          
    }
    drawBulletCell(){
        ctx.fillStyle = `rgb(100,0,0)` ;
        ctx.fillRect( this.col*CELL_SIZE, this.row*CELL_SIZE, CELL_SIZE, CELL_SIZE ) ;
    }
}
class MyTank {
    static totalTanks = 0 ;
    static SHIELD_HIGHEST = 20 ;
    static HIGHEST_HP = 8 ;
    hp = MyTank.HIGHEST_HP ;
    time = 0 ;
    row = 30 ;
    col = 20 ;
    isShieldON = false ;
    shieldHP = MyTank.SHIELD_HIGHEST ;
    bombBeginTime = 0 ; 
    lastBulletTime = 0 ;
    lastShieldSwitchTime = 0 ;
    constructor(row, col, keyController ) {
        this.tankId = MyTank.totalTanks++ ;
        this.keyController = keyController ;
        this.row = row ;
        this.col = col ;
        this.audio = document.createElement("audio");
        this.bombAudio = document.createElement("audio");
        this.bulletAudio = document.createElement("audio");
    }
    attacked() {
        this.bombBeginTime = 0 ;
        this.audio.src = "y1491.mp3";
        this.audio.play();
        this.hp-- ;
        if(this.hp<=0){
            isRun = false ;
            //tanks.splice(i,1) ;
        }
    }

    getBombLevel() {
        if ( this.bombBeginTime == 0 ) {
            return 0 ;
        }
        let deltaTime = Date.now() - this.bombBeginTime ;  
        let bombLevel = Math.round( deltaTime / 2000 ) ;
        if ( bombLevel > 8 ) {
            bombLevel = 8 ;
        }
        return bombLevel ;
    }

    fireBomb() {
        let bombLevel = this.getBombLevel() ;
        if ( bombLevel == 0 ) {
            return ;
        }

        let rowCount = bombLevel+(bombLevel-1) ;
        let deltaCol = 0 ;

        for( let row=0; row<rowCount; row++ ) {
            let colCount = Math.abs(deltaCol)*2+1  ;
            //console.log( `${deltaCol}, ${colCount}` ) ;
            for( let col=0; col<colCount; col++ ) {
                tanks.push( new MyBomb( this.row-rowCount+row, this.col+deltaCol+col )) ;
            }
            if ( row >= bombLevel-1 ) {
                deltaCol++ ;
            } else {
                deltaCol-- ;
            }
        }
        if (bombLevel>1){
            tanks.push( new Light( this.row , this.col , rowCount*CELL_SIZE , rowCount*CELL_SIZE )) ;
        } else {
            this.bombAudio.src = "y2271.mp3";
            this.bombAudio.play();
        }
        this.bombBeginTime = 0 ;
    }
    checkIfUnderAttack() {
        for(let i=0;i<tanks.length;i++){
            if (tanks[i] instanceof Bullet ){
                if ( this.row==tanks[i].row&&this.col==tanks[i].col ){
                    this.attacked() ;
                    this.time = 0
                    this.keyDown() ;
                    tanks.splice(i,1) ;
                }
                if ( this.isShieldON ){
                    if ( typeof this.row === 'undefined' || typeof tanks[i].row === 'undefined' ) {
                        console.log(this.row) ;
                        console.log(tanks[i].row) ;
                    }
                    if ( (this.row-1)==tanks[i].row&&(this.col-2)==tanks[i].col ){
                        this.shieldHP-=1 ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        break;

                    }
                    if ( (this.row-2)==tanks[i].row&&(this.col-1)==tanks[i].col ){
                        this.shieldHP-=1 ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        break;
                    }
                    if ( (this.row-2)==tanks[i].row&&this.col==tanks[i].col ){
                        this.shieldHP-=1 ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        break ;
                    }
                    if ( (this.row-2)==tanks[i].row&&(this.col+1)==tanks[i].col ){
                        this.shieldHP-=1 ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        break ;
                    }
                    if ( (this.row-1)==tanks[i].row&&(this.col+2)==tanks[i].col ){
                        this.shieldHP-=1 ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        break ;
                    }
                }
            }
        }
        if ( this.shieldHP <= 0  ) {
            this.shieldHP = MyTank.SHIELD_HIGHEST ;
            this.isShieldON = false ;
        }

    }
    process() {
        if ( this.keyController.isArrowRightPressed() ) {
            this.keyRight();
        }
        if ( this.keyController.isArrowLeftPressed() ) {
            this.keyLeft();
        }
        if ( this.keyController.isArrowDownPressed() ) {
            this.keyDown();
        }
        if ( this.keyController.isArrowUpPressed()) {
            this.keyUp() ;
        }
        if ( this.keyController.isButtonAPressed() ) {
            this.keySpace();  
        }
        if ( this.keyController.isButtonXPressed() ) {
            this.keyShield();  
        }
        if ( this.keyController.isButtonBPressed() ) {
            if ( this.bombBeginTime == 0 ) {
                this.bombBeginTime = Date.now() ;
            }
        } else {
            if ( this.bombBeginTime != 0 ) {
                this.fireBomb() ;
            }
        }
        this.checkIfUnderAttack() ;
        this.drawMyCell() ;
    }
    keyUp() {
        this.row-=1 ;
        if (this.row<20){
            this.row = 20  ;
        }
        this.checkFirstAidKit() ;
    }
    keyDown() {
        this.row+=1 ;
        if (this.row>39){
            this.row = 39 ;
        }
        this.checkFirstAidKit() ;
    }
    keyRight() {
        this.col+=1 ;
        if (this.col>39){
            this.col = 39 ;
        }
        this.checkFirstAidKit() ;
    }
    keyLeft() {
        this.col-=1 ;
        if (this.col<0){
            this.col = 0 ;
        }
        this.checkFirstAidKit() ;
    }
    checkFirstAidKit(){
        for( let i=0; i<tanks.length; i++ ) {
            if (tanks[i] instanceof firstAidKit){
                if (this.row==tanks[i].row&&this.col==tanks[i].col){
                    this.hp+=3 ;
                    if (this.hp >MyTank.HIGHEST_HP){
                        this.hp = MyTank.HIGHEST_HP ;
                    }
                    tanks[i].hp = 0 ;
                }
            }
        }
    }
    keySpace() {
        this.bombBeginTime = 0;
        if ( !this.isShieldON ) {
            if ( Date.now() - this.lastBulletTime > 300 ) {
                tanks [tanks.length] = new MyBullet(this.row,this.col) ;
                this.bulletAudio.src = "y2271.mp3";
                this.bulletAudio.pause(); 
                this.bulletAudio.currentTime = 0;
                this.bulletAudio.play();
                this.lastBulletTime = Date.now() ;
            }
        }
    }
    keyShield() {
        this.bombBeginTime = 0;
        if ( Date.now() - this.lastShieldSwitchTime < 200 ) {
            return ;
        }
        this.isShieldON = !this.isShieldON ;
        this.lastShieldSwitchTime = Date.now() ;
    }

    keyMyBomb() {
       
    }
    keyEvent(event ) {
        if (event.code==`ArrowUp`){
            this.keyUp();
        }
        if (event.code==`ArrowDown`){
            this.keyDown();
        }
        if (event.code==`ArrowRight`){
            this.keyRight();
        }
        if (event.code==`ArrowLeft`){
            this.keyLeft() ;
        }
        if (event.code==`Space`){
            this.keySpace();
        }
    }


    drawMyCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "M.tankImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 0 ) ;
        if (this.isShieldON  ){
            let color = 255/MyTank.SHIELD_HIGHEST*this.shieldHP ;
            ctx.fillStyle = `rgb(${color},${color},${color})` ;
            ctx.fillRect( (this.col-2)*CELL_SIZE+1, (this.row-1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col-1)*CELL_SIZE+1, (this.row-2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+1)*CELL_SIZE+1, (this.row-2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+2)*CELL_SIZE+1, (this.row-1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
            y = ((this.row-2)*CELL_SIZE+1) + CELL_SIZE/2 ;
            drawImg( "M.shieldImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 180 ) ;
        }   
        ctx.fillStyle = `rgb(255,0,0)` ;
        for( let i=0; i<this.hp; i++ ) {
            ctx.fillRect( (this.col-1)*CELL_SIZE, (this.row*CELL_SIZE)+20-i*4, 3, 3 ) ;
        }

        let bombLevel = this.getBombLevel() ;
        ctx.fillStyle = `rgb(0,255,255)` ;
        for( let i=0; i<bombLevel; i++ ) {
            ctx.fillRect( (this.col-1)*CELL_SIZE+5, (this.row*CELL_SIZE)+20-i*4, 3, 3 ) ;
        }
    }
}

class AutoMyTank extends MyTank {

    process() {
        if ( this.isShieldON == true ) {
            this.keyShield() ;
        }
        this.keySpace() ;
        this.keyShield() ;

        let dir = Math.floor( Math.random() * 4) ;
        switch( dir ) {
            case 0:
                this.keyUp() ;
                break;
            case 1:
                this.keyRight() ;
                break;
            case 2:
                this.keyDown() ;
                break;
            case 3:
                this.keyLeft() ; 
                break;
        }

        this.checkIfUnderAttack() ;
        this.drawMyCell() ;
    }
}

class MyBullet{
    row = 0 ;
    col = 0 ;
    hp = 1 ;
    constructor(row,col) {
        this.row = row ;
        this.col = col ;
    }
    
    process(){
        if ( this.hp == 0) {
            return ;
        }
        this.row-=1 ;    
        if (this.row<0){
            this.hp=0 ; 
        } 

        this.drawBulletCell() ;
        for (let i=0;i<tanks.length;i++){
            if ( tanks[i] instanceof Tank ) {        
                if ( tanks[i].attack( this.row, this.col ) ) {
                    this.hp = 0 ;
                    return ;
                } 
            }
        }
    }
    drawBulletCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "lightImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 0 ) ;
    }
}
class MyBomb{
    row = 0 ;
    col = 0 ;
    hp = 20 ;
    constructor(row,col) {
        this.row = row ;
        this.col = col ;
    }
    
    process(){
        if ( this.hp==0 ) {
            return ;
        }
        this.row-=1 ;    
        if (this.row<0){
            this.hp=0 ; 
        }
        for (let i=0;i<tanks.length;i++){
            if ( (tanks[i] instanceof Tank) ){
                if ( tanks[i].attack( this.row, this.col ) ) {
                    if (!tanks[i] instanceof Light ){
                        this.hp = 0 ;
                    return ;
                    }
                } 
            }
        }
        
        
    }

}
class Light extends MyBomb{
    rotation = 0 ;
    constructor(row,col,width,height) {
        super(row,col) ;
        this.width=width ;
        this.height = height ;
    }
    process(){
        if ( this.hp<0 ) {
            return ;
        }
        this.row-=1 ;
        if ((this.row+((this.height+1)/2))<0){
            this.hp=0 ; 
        }
        this.drawBulletCell() ;
        for (let i=0;i<tanks.length;i++){
            if (!(tanks[i] instanceof  Bullet)  && !(tanks[i] instanceof  MyBullet) && !(tanks[i] instanceof MyBomb)&& !(tanks[i] instanceof  Light)){
                if (!tanks[i] instanceof firstAidKit){
                    if ( tanks[i].attack( this.row, this.col ) ) {
                        if (!tanks[i] instanceof Light ){
                            this.hp = 0 ;
                            return ;
                        }
                    } 
                }
            }
        }
        
        
    }
    drawBulletCell(){
//        console.log(this.row);
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "lightImg", x, y, this.width*5/4, this.height*5/4, this.rotation ) ;
//        console.log(`${this.width},${this.width}`);
        this.rotation+= 20 ;
    }
}
class firstAidKit{
    row = (TOTAL_ROWS/2)+Math.floor(Math.random()*(TOTAL_ROWS/2)) ;
    col = +Math.floor(Math.random()*TOTAL_COLS) ;
    hp = 1 ;
    draw(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "firstaidkit", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 0 ) ;
    }
    process(){
        this.draw() ;
    }
}
class KeyController {
    static ids = 0 ;
    id = KeyController.ids++ ;
    keysState = new Map() ;
    constructor( padIdx ) {
        this.padIdx = padIdx ;
        if ( this.id == 0 ) {
            this.keyCodeLeft = "ArrowLeft" ;
            this.keyCodeRight = "ArrowRight" ;
            this.keyCodeDown = "ArrowDown" ;
            this.keyCodeUp = "ArrowUp" ;
            this.keyCodeToX = "KeyH" ;
            this.keyCodeToA = "KeyN" ;
            this.keyCodeToB = "KeyM" ;
            this.keyCodeToY = "KeyJ" ;
        } else {
            this.keyCodeLeft = "KeyA" ;
            this.keyCodeRight = "KeyD" ;
            this.keyCodeDown = "KeyS" ;
            this.keyCodeUp = "KeyW" ;
            this.keyCodeToX = "KeyF" ;
            this.keyCodeToA = "KeyC" ;
            this.keyCodeToB = "KeyV" ;
            this.keyCodeToY = "KeyG" ;
        }
        document.addEventListener("keydown", this._keyDown.bind(this) );
        document.addEventListener("keyup", this._keyUp.bind(this) );
    }
    _keyDown(event) {
        this.keysState.set( event.code, true ) ;
    }
    _keyUp(event){
        this.keysState.set( event.code, false ) ;
    }
    isArrowLeftPressed() {
        let flag = this.keysState.get( this.keyCodeLeft ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if ( gamepad != null && gamepad.axes[0] == -1 ) {
            return true ;
        }
        return false ;
    }
    isArrowRightPressed() {
        let flag = this.keysState.get( this.keyCodeRight ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if ( gamepad != null &&  gamepad.axes[0] == 1 ) {
            return true ;
        }
        return false ;
    }
    isArrowDownPressed() {
        let flag = this.keysState.get( this.keyCodeDown ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.axes[1] == 1 ) {
            return true ;
        }
        return false ;
    }
    isArrowUpPressed() {
        let flag = this.keysState.get( this.keyCodeUp ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.axes[1] == -1 ) {
            return true ;
        }
        return false ;
    }
    isButtonAPressed() {
        let flag = this.keysState.get( this.keyCodeToA ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[0].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonBPressed() {
        let flag = this.keysState.get( this.keyCodeToB ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[1].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonXPressed() {
        let flag = this.keysState.get( this.keyCodeToX ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[2].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonYPressed() {
        let flag = this.keysState.get( this.keyCodeToY ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[3].pressed ) {
            return true ;
        }
        return false ;
    }

}
//=============================================

let countDown = 3000 ;
const CELL_SIZE = 14 ;
const TOTAL_ROWS = 40 ;
const TOTAL_COLS = 40 ;
let isRun = true ;
let lastTime = 0 ;
let tanks = [] ; 
let target = [] ;
let wave = 0 ;

function drawImg(imgId, x, y, width, height, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(( rotation * Math.PI) / 180);
        ctx.translate( -x, -y);
        let imgObj = document.getElementById( imgId) ;
        ctx.drawImage(imgObj, x-width/2, y-height/2, width, height ) ;
        ctx.restore();    
}

function drawBackground(){
    ctx.strokeStyle = "orange";
    for (let i=0;i<40+1;i++){
        ctx.moveTo(CELL_SIZE*i,0 );
        ctx.lineTo(CELL_SIZE*i,CELL_SIZE*40);
    } 
    for (let j=0;j<40+1;j++){
        ctx.moveTo(0,CELL_SIZE*j );
        ctx.lineTo(CELL_SIZE*40,CELL_SIZE*j);    
    }
    ctx.stroke();
}



for (let i=0;i<1;i++){
    tanks [tanks.length] = new Tank () ;
}
for (let i=0;i<0;i++){
    tanks [tanks.length] = new BabyTank () ;
}
for (let i=0;i<0;i++){
    tanks [tanks.length] = new ShieldPeople () ;
}

function getTankNumbers() {
    let count = 0 ;
    for( let i=0; i<tanks.length; i++ ) {
        if ( tanks[i] instanceof Tank ) {
            count++ ;
        }
    }
    return count ;
}
function run(time) {
    if (lastTime === 0) {
        lastTime = time;
    }

    // 計算自上次更新以來經過的時間
    const deltaTime = time - lastTime
    if ( deltaTime < 50 ) {
        requestAnimationFrame(run);
        return ;
    }
    lastTime = time ;
    ctx.fillStyle = `rgb(0,0,0)` ;
    ctx.fillRect( 0 , 0 , 560 , 560 ) ;

    if (wave < 9 ){
        if (wave == 8){
            ctx.fillStyle = `rgb(255,0,0)` ;
            ctx.font = "20px Arial";
            ctx.fillText(" 前方高能 ",460,560);
        }else{
            ctx.fillStyle = `rgb(255,255,255)` ;
            ctx.font = "20px Arial";
            ctx.fillText(`第${wave}波`,500,560 );
        }
    }
    ctx.fillStyle = `rgb(255,255,255)` ;
    ctx.font = "20px Arial";
    ctx.fillText(`我方${target.length}隻`,0,560 );
    let tankNumbers = getTankNumbers() ;
    ctx.font = "20px Arial";
    ctx.fillText(`敵方${tankNumbers}隻`,250,20 );
    for (let i=0;i<tanks.length;i++){
        if (tanks [i].hp<=0 ){
            tanks.splice(i--,1) ;
        } else {
            tanks [i].process() ;
        }
    }  
    for (let j=0;j<target.length;j++ ){
        if (target[j].hp<=0){
            target.splice(j--,1) ;
        }else{
            target[j].process() ;
        }
    }
    for ( let j=0; j<Entity.objs.length; j++ ) {
        if ( Entity.objs[j].hp <= 0 ) {
            Entity.objs.splice(j--,1) ;
        } else {
            Entity.objs[j].process() ;
        }
    }
    if (target.length == 0){
        ctx.fillStyle = `rgb(255,0,0)` ;
        ctx.font = "80px Arial";
        ctx.fillText("GAME OVER",20,350);
    }

    if ( tankNumbers == 0 ) {
        wave++ ;
        if (wave < 8 ) {
            for ( let i= 0;i<wave;i++ ) {
                tanks.push( new SuperTank() ) ;
            }
        } 
        if ( wave == 8 ) {
            tanks.push( new BigTank() ) ;
        }
        if ( wave > 8 ) {
            ctx.fillStyle = `rgb(0,255,0)` ;
            ctx.font = "200px Arial";
            ctx.fillText("WIN",50,350 );
        }
    }
    if (Math.floor(Math.random()*400) == 0){
        tanks [tanks.length] = new firstAidKit () ;
    }
    requestAnimationFrame(run);
}

window.onload=function() {
    for (let i=0;i<1;i++){
        target[target.length] = new MyTank(30, 20, new KeyController(i) );
    }
    //for (let i=0;i<49;i++){
    //    target[target.length] = new AutoMyTank(30, 20, new KeyController(i) );
    //}
    new OurTank( new Coord(30, 30), 0 ) ;
    requestAnimationFrame(run);
}

</script> 