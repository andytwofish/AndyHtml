<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>bee</title>
  <style>
    canvas { border: 1px solid #000; }
  </style>
</head>
<body>
    <canvas id="_Canvas" width="560" height="560"></canvas>
    <img id="babyTankImg" src="./icons8-alien-monster-94.png" alt="Source Image" style="display:none;">
    <img id="M.shieldImg" src="./icons8-shield-48 2.png" alt="Source Image" style="display:none;">
    <img id="E.shieldImg" src="./icons8-shield-48.png" alt="Source Image" style="display:none;">
    <img id="tankImg" src="./icons8-tank-16.png" alt="Source Image" style="display:none;">
    <img id="M.tankImg" src="./icons8-tank-top-view-50 1.png" alt="Source Image" style="display:none;">
    <img id="peopleImg" src="./icons8-top-view-man-48 1.png" alt="Source Image" style="display:none;">
    <img id="M.bulletImg" src="./icons8-bullet-64.png" alt="Source Image" style="display:none;">
    <img id="E.bulletImg" src="./icons8-bullet-24.png" alt="Source Image" style="display:none;">
    <img id="lightImg" src="./—Pngtree—light effect of lightning blue_6183369.png" alt="Source Image" style="display:none;">
</body>
</html>

<script>

const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');     

class ShieldTank{
    shieldGenerated = 0 ;
    static CELL_SIZE = 14 ;
    shield = true ;
    h = 0 ;
    row = Math.floor(Math.random()*39) ;  
    col = Math.floor(Math.random()*39) ; 
    red = 100 ;
    green = 100 ;
    blue = 0 ;
    life = true ;
    lastMoveTime = 0 ;
    drawCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "peopleImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 180 ) ;
    
        if (this.shield){
            ctx.fillStyle = `rgb(${this.red},${this.green},${this.blue})` ;
            ctx.fillRect( (this.col-2)*CELL_SIZE+1, (this.row+1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col-1)*CELL_SIZE+1, (this.row+2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+1)*CELL_SIZE+1, (this.row+2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+2)*CELL_SIZE+1, (this.row+1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
            y = ((this.row+2)*CELL_SIZE+1) + CELL_SIZE/2 ;
            drawImg( "E.shieldImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 0 ) ;
        }   
    }


    //傳入被攻的位置，
    //傳出boolean  true:有打到  false:沒打到
    attack( row, col ) {
        if (this.shield){
            //console.log(`${row}, ${col}, ${this.row}, ${this.col}`) ;
            if ( row==this.row+1&&col==this.col-2 ){
                this.shield = false ;
                if (this.row>0){
                    row-=1 ;
                }
                return true;
            }
            if ( row==this.row+2&&col==this.col-1 ){
                this.shield = false ;
                if (this.row>0){
                    row-=1 ;
                }
                return true;
            }
            if ( row==this.row+2&&col==this.col ){
                this.shield = false ;
                if (this.row>0){
                    row-=1 ;
                }
                return true;
            }
            if ( row==this.row+2&&col==this.col+1 ){
                this.shield = false ;
                if (this.row>0){
                    row-=1 ;
                }
                return true;
            }
            if ( row==this.row+1&&col==this.col+2 ){
                this.shield = false ;
                if (this.row>0){
                    row-=1 ;
                }
                return true;
            }
        }
        if ( row==this.row&&col==this.col ){
            this.life = false ;
            return true;
        }
        return false ;
    }

    move(){
        if (this.shield){
            this.shieldGenerated = 0 ;
        }else{
            this.shieldGenerated+=1 ;
        }
        if ( Date.now() - this.lastMoveTime > 500 ) {
            let i = Math.floor(Math.random()*2) ;
            this.h = Math.floor(Math.random()*2) ;
            if (this.h==0){
                this.h=-1;
            }else{
                this.h=1 ;
            }
            if (i==0){
                this.row+=this.h ;
            }else{
                this.col+=this.h ;
            }
            this.lastMoveTime = Date.now() ;
        }
        if (this.row<0){
            this.row = 0  ;
        }
        if (this.shield){
            if (this.row>19-2){
                this.row = 19-2 ;
            }
        }else{
            if (this.row>19){
                this.row = 19 ;
            }
        }
        if (this.col<0){
            this.col = 0 ;
        }
        if (this.col>39){
            this.col = 39 ;
        }
        if ( this.shieldGenerated>19 ) {
            this.shield = true ;
        }
        this.drawCell() ;
        //for (let i=0;i<tanks.length;i++){
        //    if ( tanks[i].row==myTank.row&&tanks[i].col==myTank.col ){
        //        tanks.splice(i,1) ;
        //        if (tanks.length==0){
        //            console.log("ture:0") ; 
        //        }else{
        //            console.log(`false:${tanks.length}`) ;
        //        }
        //        return ;
        //    }
        //}
    }
}


function drawImg(imgId, x, y, width, height, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(( rotation * Math.PI) / 180);
        ctx.translate( -x, -y);
        let imgObj = document.getElementById( imgId) ;
        ctx.drawImage(imgObj, x-width/2, y-height/2, width, height ) ;
        ctx.restore();    
}

class BabyTank{
    static CELL_SIZE = 14 ;
    h = 0 ;
    row = Math.floor(Math.random()*39) ;  
    col = Math.floor(Math.random()*39) ; 
    red = 200 ;
    green = 10 ;
    blue = 10 ;
    life = true ;

    drawCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "babyTankImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 0 ) ;
    }
    //傳入被攻的位置，
    //傳出boolean  true:有打到  false:沒打到
    attack( row, col ) {
        if ( row==this.row&&col==this.col ){
            this.life = false ;
            return true;
        }
        return false ;
    }

    move(){
//        this.cleanCell() ;
        let i = Math.floor(Math.random()*2) ;
        if (i==0){
            this.h = Math.floor(Math.random()*3)-2 ;
        }else{
            this.h = Math.floor(Math.random()*2) ;
            if (this.h==0){
                this.h = -1 ;
            }
        }
        if (i==0){
            
            this.row+=this.h ;
        }else{
            this.col+=this.h ;
        }
        if (this.row<0){
            this.row = 0  ;
        }
        if (this.row>19){
            this.row = 19 ;
        }
        if (this.col<0){
            this.col = 0 ;
        }
        if (this.col>39){
            this.col = 39 ;
        }
        if ( Math.floor(Math.random()*40)<=0 ) {
            tanks [tanks.length] = new Tank () ;
            tanks [tanks.length-1].row = this.row+=1 ;
            tanks [tanks.length-1].col = this.col ;
        }
        if ( Math.floor(Math.random()*40)<=0 ) {
            tanks [tanks.length] = new ShieldTank () ;
            tanks [tanks.length-1].row = this.row+=1 ;
            tanks [tanks.length-1].col = this.col ;
        }
        this.drawCell() ;
        //for (let i=0;i<tanks.length;i++){
        //    if ( tanks[i].row==myTank.row&&tanks[i].col==myTank.col ){
        //        tanks.splice(i,1) ;
        //        if (tanks.length==0){
        //            console.log("ture:0") ; 
        //        }else{
        //            console.log(`false:${tanks.length}`) ;
        //        }
        //        return ;
        //    }
        //}
    }
}

class Tank{

    life = true ;
    h = 0 ;
    row = Math.floor(Math.random()*39) ;  
    col = Math.floor(Math.random()*39) ; 
    red = 100 ;
    green = 100 ;
    blue = 100 ;
//    red = Math.floor(Math.random()*256) ;
//    green = Math.floor(Math.random()*256) ;
//    blue = Math.floor(Math.random()*256) ;
//    red = Math.floor(Math.random()*56)+200 ;
//    green = Math.floor(Math.random()*56)+200 ;
//    blue = Math.floor(Math.random()*56)+200 ;
    static drawBackground(){
        ctx.strokeStyle = "orange";
        for (let i=0;i<40+1;i++){
            ctx.moveTo(CELL_SIZE*i,0 );
            ctx.lineTo(CELL_SIZE*i,CELL_SIZE*40);
        } 
        for (let j=0;j<40+1;j++){
            ctx.moveTo(0,CELL_SIZE*j );
            ctx.lineTo(CELL_SIZE*40,CELL_SIZE*j);    
        }
        ctx.stroke();
    }
    drawCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "tankImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 180 ) ;
    }
    //傳入被攻的位置，
    //傳出boolean  true:有打到  false:沒打到
    attack( row, col ) {
        if ( row==this.row&&col==this.col ){
            this.life = false ;
            return true ;
        }
        return false ;
    }

    move(){
//        this.cleanCell() ;
        let i = Math.floor(Math.random()*2) ;
        this.h = Math.floor(Math.random()*2) ;
        if (this.h==0){
            this.h=-1;
        }else{
            this.h=1 ;
        }
        if (i==0){
            this.row+=this.h ;
        }else{
            this.col+=this.h ;
        }
        if (this.row<0){
            this.row = 0  ;
        }
        if (this.row>19){
            this.row = 19 ;
        }
        if (this.col<0){
            this.col = 0 ;
        }
        if (this.col>39){
            this.col = 39 ;
        }
        if ( Math.floor(Math.random()*60)<=0 ) {
            tanks [tanks.length] = new Bullet(this.row,this.col,this.red,this.green,this.blue) ;
        }
        this.drawCell() ;
        //for (let i=0;i<tanks.length;i++){
        //    if ( tanks[i].row==myTank.row&&tanks[i].col==myTank.col ){
        //        tanks.splice(i,1) ;
        //        if (tanks.length==0){
        //            console.log("ture:0") ; 
        //        }else{
        //            console.log(`false:${tanks.length}`) ;
        //        }
        //        return ;
        //    }
        // }
        // for (let i=0;i<tanks.length;i++){
        //     if ( tanks[i] !=this&&tanks[i].row==this.row&&tanks[i].col==this.col ){
        //         tanks.splice(i,1) ;
        //         return ;
        //     }
        // }
    }
}

class Bullet{
    bullet = [] ;
    row = 0 ;
    col = 0 ;
    red = 0 ;
    green = 0 ;
    blue = 0 ;
    life = true ;
    constructor(row,col,red,green,blue) {
        this.row = row ;
        this.col = col ;
        this.red = red ;
        this.green = green ;
        this.blue = blue ;
        //this.move();
    }
    
    move(){
        if ( !this.life ) {
            return ;
        }
//        this.cleanBulletCell() ;
        this.row+=1 ;    
        if (this.row>39){
            this.life=false ; 
        } 
        
        this.drawBulletCell() ;
//        setTimeout( this.move.bind(this), 30 ) ;
        
    }
    drawBulletCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "M.bulletImg", x, y, CELL_SIZE, CELL_SIZE, 180 ) ;
    }
}

class MyTank {
    static totalTanks = 0 ;
    static SHIELD_HIGHEST = 20 ;
    static HIGHEST_HP = 8 ;
    HP = MyTank.HIGHEST_HP ;
    shieldHp = 0 ;
    time = 0 ;
    row = 30 ;
    col = 20 ;
    loaded = false ;
    loaded2 = false ;
    isKeyDown = false ;
    lastKeyEvent=0;
    keyDelayCount=0;
    gamepadIdx= 0;
    shield = 0 ;
    bulletCount = 0 ;
    bombBeginTime = 0 ; 
    lastBulletTime = 0 ;
    constructor(row, col, keyController ) {
        this.tankId = MyTank.totalTanks++ ;
        this.keyController = keyController ;
        this.row = row ;
        this.col = col ;
        this.audio = document.createElement("audio");
        this.bombAudio = document.createElement("audio");
        this.bulletAudio = document.createElement("audio");
    }
    attacked() {
        this.audio.src = "y1491.mp3";
        this.audio.play();
        this.HP-- ;
        if(this.HP<=0){
            isRun = false ;
            this.life = false ;
            //tanks.splice(i,1) ;
        }
    }
    fireBomb() {
        if ( this.bombBeginTime == 0 ) {
            return ;
        }
        let deltaTime = Date.now() - this.bombBeginTime ;  // millie seconds
        let bombLevel = Math.round( deltaTime / 2000 ) ;
        let rowCount = bombLevel+(bombLevel-1) ;
        let deltaCol = 0 ;

        for( let row=0; row<rowCount; row++ ) {
            let colCount = Math.abs(deltaCol)*2+1  ;
            //console.log( `${deltaCol}, ${colCount}` ) ;
            for( let col=0; col<colCount; col++ ) {
                tanks.push( new MyBomb( this.row-rowCount+row, this.col+deltaCol+col )) ;
            }
            if ( row >= bombLevel-1 ) {
                deltaCol++ ;
            } else {
                deltaCol-- ;
            }
        }
        if (bombLevel>1){
            tanks.push( new Light( this.row-((rowCount+1)/2) , this.col , rowCount*CELL_SIZE , rowCount*CELL_SIZE )) ;
        } else {
            this.bombAudio.src = "y2271.mp3";
            this.bombAudio.play();
        }
        this.bombBeginTime = 0 ;
    }
    _keyDown(event) {
        if ( event.code == "IntlRo" ) {
            return ;
        }
        if ( this.lastKeyEvent > 0 && event.code == this.lastKeyEvent.code && this.isKeyDown ){
            return ;
        }
        this.lastKeyEvent = event ;
        this.isKeyDown = true ;
        this.keyEvent(event) ;
        setTimeout( this._keyLoop.bind(this), 84 ) ;
    }
    _keyLoop() {
        if ( this.isKeyDown ) {
            this.keyEvent(this.lastKeyEvent) ;
            setTimeout( this._keyLoop.bind(this), 50 ) ;
        }
    }
    _keyUp(event) {
        this.time = 0 ;
        this.lastKeyEvent = 0 ;
        this.isKeyDown = false ;
        this.loaded = false ;
        this.loaded2 = false ;
    }
    process() {
        if ( this.keyController.isArrowRightPressed() ) {
            this.fireBomb();
            this.keyRight();
        }
        if ( this.keyController.isArrowLeftPressed() ) {
            this.fireBomb();
            this.keyLeft();
        }
        if ( this.keyController.isArrowDownPressed() ) {
            this.fireBomb();
            this.keyDown();
        }
        if ( this.keyController.isArrowUpPressed()) {
            this.fireBomb();
            this.keyUp() ;
        }
        if ( this.keyController.isButtonAPressed() ) {
            this.fireBomb();
            this.keySpace();  
        }else{
            this.bulletCount = 0 ;//this.loaded = false ;
        }
        if ( this.keyController.isButtonXPressed() ) {
            this.fireBomb();
            this.keyShield();  
        }else{
            this.loaded2 = false ;
        }
        if ( this.keyController.isButtonBPressed() ) {
            if ( this.bombBeginTime == 0 ) {
                this.bombBeginTime = Date.now() ;
                console.log(this.bombBeginTime);
            }
        } else {
            if ( this.bombBeginTime != 0 ) {
                this.fireBomb() ;
            }
        }
        for(let i=0;i<tanks.length;i++){
            if (tanks[i] instanceof Bullet ){
                if ( this.row==tanks[i].row&&this.col==tanks[i].col ){
                    this.attacked() ;
                    this.time = 0
                    this.keyDown() ;
                    tanks.splice(i,1) ;
                }
                if ( this.shield > 0 ){
                    if ( (this.row-1)==tanks[i].row&&(this.col-2)==tanks[i].col ){
                        this.shield-=1 ;
                        this.life = false ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        return ;

                    }
                    if ( (this.row-2)==tanks[i].row&&(this.col-1)==tanks[i].col ){
                        this.shield-=1 ;
                        this.life = false ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        return ;
                    }
                    if ( (this.row-2)==tanks[i].row&&this.col==tanks[i].col ){
                        this.shield-=1 ;
                        this.life = false ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        return ;
                    }
                    if ( (this.row-2)==tanks[i].row&&(this.col+1)==tanks[i].col ){
                        this.shield-=1 ;
                        this.life = false ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        return ;
                    }
                    if ( (this.row-1)==tanks[i].row&&(this.col+2)==tanks[i].col ){
                        this.shield-=1 ;
                        this.life = false ;
                        this.keyDown() ;
                        tanks.splice(i,1) ;
                        return ;
                    }
                }
            }
        }
        this.drawMyCell() ;
    }
    keyUp() {
        this.row-=1 ;
        if (this.row<20){
            this.row = 20  ;
        }
    }
    keyDown() {
        this.row+=1 ;
        if (this.row>39){
            this.row = 39 ;
        }
    }
    keyRight() {
        this.col+=1 ;
        if (this.col>39){
            this.col = 39 ;
        }
    }
    keyLeft() {
        this.col-=1 ;
        if (this.col<0){
            this.col = 0 ;
        }
    }
    keySpace() {
        if ( this.shield <= 0 ) {
            if ( Date.now() - this.lastBulletTime > 300 ) {
                tanks [tanks.length] = new MyBullet(this.row,this.col) ;
                this.bulletAudio.src = "y2271.mp3";
                this.bulletAudio.pause(); 
                this.bulletAudio.currentTime = 0;
                this.bulletAudio.play();
                this.lastBulletTime = Date.now() ;
            }
        }
    }
    keyShield() {
        if ( !this.loaded2 ){
            this.loaded2 = true ;
            if(this.shield <= 0){
                if ( this.shieldHp > 0 ){
                    this.shield = this.shieldHp ;
                    this.shieldHp = 0 ;
                }else{
                    this.shield =MyTank.SHIELD_HIGHEST ;
                }
            }else{
                this.shieldHp = this.shield ;
                this.shield = 0 ;
            }
        }
    }
    keyMyBomb() {
       
    }
    keyEvent(event ) {
        if (event.code==`ArrowUp`){
            this.keyUp();
        }
        if (event.code==`ArrowDown`){
            this.keyDown();
        }
        if (event.code==`ArrowRight`){
            this.keyRight();
        }
        if (event.code==`ArrowLeft`){
            this.keyLeft() ;
        }
        if (event.code==`Space`){
            this.keySpace();
        }
    }

    drawMyCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "M.tankImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 0 ) ;
        if (this.shield > 0 ){
            let color = 255/MyTank.SHIELD_HIGHEST*this.shield ;
            ctx.fillStyle = `rgb(${color},${color},${color})` ;
            ctx.fillRect( (this.col-2)*CELL_SIZE+1, (this.row-1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col-1)*CELL_SIZE+1, (this.row-2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+1)*CELL_SIZE+1, (this.row-2)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            ctx.fillRect( (this.col+2)*CELL_SIZE+1, (this.row-1)*CELL_SIZE+1, CELL_SIZE-2, CELL_SIZE-2 ) ;
            x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
            y = ((this.row-2)*CELL_SIZE+1) + CELL_SIZE/2 ;
            drawImg( "M.shieldImg", x, y, CELL_SIZE*2, CELL_SIZE*2, 180 ) ;
        }   
    }
}

class MyBullet{
    row = 0 ;
    col = 0 ;
    life = true ;
    constructor(row,col) {
        this.row = row ;
        this.col = col ;
        console.log('=======');
    }
    
    move(){
        if ( !this.life ) {
            return ;
        }
//        this.cleanBulletCell() ;
        this.row-=1 ;    
        if (this.row<0){
            this.life=false ; 
        } 

        this.drawBulletCell() ;
//            setTimeout( this.move.bind(this), 20 ) ;
        for (let i=0;i<tanks.length;i++){
            //if (!(tanks[i] instanceof  Bullet)  && !(tanks[i] instanceof  MyBullet)&& !(tanks[i] instanceof  MyBomb)&& !(tanks[i] instanceof  Light)){
                if ( tanks[i] instanceof ShieldTank ) {        
                    if ( tanks[i].attack( this.row, this.col ) ) {
                        console.log('--------------------中');
                        this.life = false ;
                        return ;
                    } 
                }
            //}
            // if ( tanks[i].row==this.row&&tanks[i].col==this.col ){
            //     tanks.splice(i,1) ;
            //     this.life = false ;
            //     return ;
            // }
        }
    }
    drawBulletCell(){
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "lightImg", x, y, CELL_SIZE*3/2, CELL_SIZE*3/2, 0 ) ;
    }
}
class MyBomb{
    row = 0 ;
    col = 0 ;
    life = true ;
    constructor(row,col) {
        this.row = row ;
        this.col = col ;
    }
    
    move(){
        if ( !this.life ) {
            return ;
        }
        this.row-=1 ;    
        if (this.row<0){
            this.life=false ; 
        }
        this.drawBulletCell() ;
        for (let i=0;i<tanks.length;i++){
            if (!(tanks[i] instanceof  Bullet)  && !(tanks[i] instanceof  MyBullet) && !(tanks[i] instanceof MyBomb)&& !(tanks[i] instanceof  Light)){
                if ( tanks[i].attack( this.row, this.col ) ) {
                    if (!tanks[i] instanceof Light ){
                    this.life = false ;
                    return ;
                    }
                } 
            }
        }
        
        
    }
    drawBulletCell(){
//        ctx.fillStyle = `rgb(0,240,240)` ;
//        ctx.fillRect( this.col*CELL_SIZE, this.row*CELL_SIZE, CELL_SIZE, CELL_SIZE ) ;
    }
}
class Light extends MyBomb{
    rotation = 0 ;
    constructor(row,col,width,height) {
        super(row,col) ;
        this.width=width ;
        this.height = height ;
    }
    move(){
        if ( !this.life ) {
            return ;
        }
        this.row-=1 ;
        if ((this.row+((this.height+1)/2))<0){
            this.life=false ; 
        }
        this.drawBulletCell() ;
        for (let i=0;i<tanks.length;i++){
            if (!(tanks[i] instanceof  Bullet)  && !(tanks[i] instanceof  MyBullet) && !(tanks[i] instanceof MyBomb)&& !(tanks[i] instanceof  Light)){
                if ( tanks[i].attack( this.row, this.col ) ) {
                    if (!tanks[i] instanceof Light ){
                    this.life = false ;
                    return ;
                    }
                } 
            }
        }
        
        
    }
    drawBulletCell(){
        console.log(this.row);
        let x = (this.col*CELL_SIZE+1) + CELL_SIZE/2 ;
        let y = (this.row*CELL_SIZE+1) + CELL_SIZE/2 ;
        drawImg( "lightImg", x, y, this.width*5/4, this.height*5/4, this.rotation ) ;
        console.log(`${this.width},${this.width}`);
        this.rotation+= 20 ;
    }
}

class KeyController {
    keysState = new Map() ;
    keyCodeToX = "" ;
    keyCodeToA = "" ;
    keyCodeToB = "" ;
    keyCodeToY = "" ;
    constructor( padIdx ) {
        document.addEventListener("keydown", this._keyDown.bind(this) );
        document.addEventListener("keyup", this._keyUp.bind(this) );
        this.padIdx = padIdx ;
    }
    _keyDown(event) {
        this.keysState.set( event.code, true ) ;
    }
    _keyUp(event){
        this.keysState.set( event.code, false ) ;
    }
    isArrowLeftPressed() {
        let flag = this.keysState.get( "ArrowLeft" ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if ( gamepad != null && gamepad.axes[0] == -1 ) {
            return true ;
        }
        return false ;
    }
    isArrowRightPressed() {
        let flag = this.keysState.get( "ArrowRight" ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if ( gamepad != null &&  gamepad.axes[0] == 1 ) {
            return true ;
        }
        return false ;
    }
    isArrowDownPressed() {
        let flag = this.keysState.get( "ArrowDown" ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.axes[1] == 1 ) {
            return true ;
        }
        return false ;
    }
    isArrowUpPressed() {
        let flag = this.keysState.get( "ArrowUp" ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.axes[1] == -1 ) {
            return true ;
        }
        return false ;
    }
    isButtonAPressed() {
        let flag = this.keysState.get( this.keyCodeToA ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[0].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonBPressed() {
        let flag = this.keysState.get( this.keyCodeToB ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[1].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonXPressed() {
        let flag = this.keysState.get( this.keyCodeToX ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[2].pressed ) {
            return true ;
        }
        return false ;
    }
    isButtonYPressed() {
        let flag = this.keysState.get( this.keyCodeToY ) ;
        if ( flag != null && flag == true ) {
            return true ;
        }
        let gamepad = navigator.getGamepads()[this.padIdx] ;
        if (  gamepad != null && gamepad.buttons[3].pressed ) {
            return true ;
        }
        return false ;
    }

}
//=============================================

let tanks = [] ; 
for (let i=0;i<0;i++){
    tanks [tanks.length] = new Tank () ;
}
for (let i=0;i<0;i++){
    tanks [tanks.length] = new BabyTank () ;
}
for (let i=0;i<1;i++){
    tanks [tanks.length] = new ShieldTank () ;
}
//Tank.drawBackground () ;
let countDown = 3000 ;
const CELL_SIZE = 14 ;
let isRun = true ;
let lastTime = 0 ;

function run(time) {
    if (lastTime === 0) {
        lastTime = time;
    }

    // 計算自上次更新以來經過的時間
    const deltaTime = time - lastTime
    if ( deltaTime < 50 ) {
        requestAnimationFrame(run);
        return ;
    }
    lastTime = time ;

    if (isRun){
        for (let i=0;i<tanks.length;i++){
            if (!tanks [i].life ){
                tanks.splice(i--,1) ;
            }
        }  
        ctx.fillStyle = `rgb(0,0,0)` ;
        ctx.fillRect( 0 , 0 , 560 , 560 ) ;
        for (let i=0;i<tanks.length;i++){
            tanks [i].move() ;
        }
        myTank1.process() ;
        myTank2.process() ;
    }else{
        ctx.font = "80px Arial";
        ctx.fillText("GAME OVER",20,350);
    }
    if (tanks.length==0){
        ctx.font = "200px Arial";
        ctx.fillText("WIN",50,350 );
    }
    requestAnimationFrame(run);
}

window.onload=function() {
    this.myTank1 = new MyTank(30, 20, new KeyController(0) );
    this.myTank2 = new MyTank(30, 20, new KeyController(1) );
    requestAnimationFrame(run);
}

</script>